/*
 * generated by Xtext 2.25.0
 */
package xtext.generator

import controller.MainController
import domain.BatchNormalisation
import domain.Concatenate
import domain.Convolution
import domain.Dense
import domain.Dropout
import domain.Pooling
import java.io.PrintWriter
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import utils.FonctionStringPy
import utils.GestionWay
import views.ArchitectureGraphView
import xtext.sML.Architecture
import xtext.sML.Classification
import xtext.sML.FeatureExtraction
import xtext.sML.Interstice
import xtext.sML.Left
import xtext.sML.Merge
import xtext.sML.MergeBody
import xtext.sML.Right
import xtext.sML.SML

import xtext.sML.impl.SMLFactoryImpl
import com.google.inject.Injector
import xtext.SMLStandaloneSetup
import org.eclipse.xtext.resource.XtextResourceSet

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SMLGenerator extends AbstractGenerator {
	
	var countryISOCode = "BEL"

	var fsp = new FonctionStringPy()
	
	var GestionWay gestionWay = null //GestionWay.gestionWay
	
	MainController mainCtrl = null
	
	ArchitectureGraphView graphview = null;
	var currentPos = 1
		
	// python directory
    var py_dir = "architecture_py/"

    
   	/*
   	 * 
   	 * USING GENERATOR
   	 * 
   	 * 
   	 * 
   	*/
    // log directory
    var log_dir = "../../architecture_log/"
    
    // png directory
    var png_dir = "../../architecture_img/"
    
    var tensorboardDir = "../../architecture_tb/"
    
    var emission_dir = "../../emissions/"
    
       // csv directory
    static String csvDir = "../../architecture_csv/";
    
    
    /*
     * 
     * USING MANUAL CONSTRUCTION
     * 
     */
    /* 
    // log directory
    var log_dir = "../architecture_log/"
    
    // png directory
    var png_dir = "../architecture_img/"
    
    // csv directory
    static String csvDir = "../architecture_csv/";
     */
    
    
	var file_name = ""
	
	var exp_dir = ""
	
	var SMLFactoryImpl factory = new SMLFactoryImpl()
	
	//var str_stride = ""
    
	// entry for ui
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		println(resource.URI)
		file_name = "architecture"
		mainCtrl = new MainController
		for(elem : resource.allContents.toIterable.filter(Architecture)){
			fsa.generateFile(py_dir + file_name + '.py', elem.compile())
		}
	}
	
	// entry for generator
	def void generate(SML sml, String filename, String expDir, String DBName) {	
	
		exp_dir = expDir
		file_name = filename.split("/").last.split('.py').get(0)

		mainCtrl = new MainController(DBName)	
		
		var archi = compile(sml.sml)
		
		
		var writer = new PrintWriter(filename, "UTF-8");
		writer.println(archi);
		writer.close();
		
	}
	
	// create py file
	private def compile(Architecture archi ){
		
		
		gestionWay = mainCtrl.gestionWay
		
		graphview = mainCtrl.graphview
		
		graphview.createGraph(archi);
		
		graphview.architectureHpp(mainCtrl.gestionHPPNeo4j)
		


		var py_file = ""
		
		
		// write import
		py_file += fsp.strImport()
		
		
		// write dataset minist
		//py_file += fsp.writeMnistDataSet()
		
		// write dataset cifar10
		py_file += fsp.writecifar10Dataset
		
		// write glo variable
		py_file += fsp.writeGlobalVariable
				
		// write init value 
		py_file += fsp.writeInitValue
		
		
		// try	
    	py_file += "try:\n"
		
		
		py_file += gestionArchi(archi)
		
		py_file += fsp.writeCallbackMethode(tensorboardDir + exp_dir + file_name);
		
		py_file += fsp.writeStartCodeCarbon(countryISOCode, file_name, emission_dir)
		
		py_file += fsp.writeTrain
		
		py_file += fsp.writeStopCodeCarbon
		
		py_file += fsp.writeFlops
		
		py_file += fsp.gestionGood(log_dir + exp_dir, file_name)
		
		py_file += fsp.gestionError(log_dir + exp_dir, file_name)
		
		py_file += fsp.gestionFinally(csvDir + exp_dir, file_name)
		
		return py_file
		
	}
	
	private def gestionArchi(Architecture a){
		var str_archi = "\tdef getModel():\n"
		
		// verify input not missing
		if (!a.input.empty){
			str_archi += fsp.writeInput("[32, 32, 3]", gestionWay.current)
		}else{
			throw new Exception("missing Input")
		}
		
		// verify feature extraction not missing
		if (!a.fe.empty){
			str_archi += gestionFE(a.fe)
			//println(a.fe)

		}else{
			throw new Exception("missing feature extra")
		}

		
		if (a.inter !== null && a.class_ !== null){
			str_archi += gestionInter(a.inter)
			str_archi += gestionDense(a.class_)
		}
		
		
		if(!a.output.empty){
			str_archi += String.format("\t\tmodel = Model(inputs=X_input, outputs=%s)\n", gestionWay.current)
			str_archi += "\t\treturn model\n\n"
			str_archi += "\tmodel = getModel()\n"
			
			// write : create png of the model
    		str_archi += String.format("\tplot_model(model, show_shapes=True, to_file=\"%s\")\n", 
    			png_dir+exp_dir+file_name+".png"
    		)
    		// write compiler
    		str_archi += "\tmodel.compile(optimizer='adam', loss=keras.losses.sparse_categorical_crossentropy, metrics=['accuracy'])\n\n"
    		
		}else{
			throw new Exception("missing output")
		}
		
		return str_archi
	}
	
	def gestionFE(EList<FeatureExtraction> list) {
		var fe_string = ""
		for (elem: list){
			if (elem.conv !== null){
				fe_string += gestionConv(elem.conv, gestionWay.current)

			}else if (elem.merge !== null){
				fe_string += gestionMerge(elem.merge, true)
			}else {
				throw new Exception("gestionFe errors")
			}
			
			if (elem.drop !== null)
				fe_string += unitDropout(gestionWay.current)
			if (elem.pool !== null)
				fe_string += unitPooling(elem.pool, gestionWay.current)
		}
		return	fe_string
	}
	
	
	def gestionConv(xtext.sML.Convolution conv, String x_or_shortcut) {
		if( conv.bnconv !== null)
			return unitBnConv(x_or_shortcut)
		else if (conv.convbn !== null)
			return unitConvBn(x_or_shortcut)
		else if (conv.conv !== null)
			return unitConv(x_or_shortcut)
		else return unitUpConv(x_or_shortcut)
	}
	
	def gestionMerge(Merge merge, boolean isRecu) {
		var str_merge = ""
		
		if(merge.mergeBody.size <= 1){
			str_merge += gestionMergeBody(merge.mergeBody.get(0), isRecu)
		}else {
			str_merge += gestionHighway(merge.mergeBody, isRecu)
		}
		
		return str_merge
	}
	
	def gestionHighway(EList<MergeBody> listMerge, boolean isRecu) {
		var str_highway = ""
		
		//init merge
		gestionWay.add
		str_highway += fsp.writeInitMerge(gestionWay.current, gestionWay.next)
		
		for (mb: listMerge){	
			// body merge (i.e Left & Right)
			str_highway += gestionLeft(mb.left,  false)
			str_highway += '\n'
			str_highway += gestionRight(mb.right, false)
			
			// end merge (i.e Add/Concatenate)
			//if(graph.getByID(currentPos) instanceof Concatenate){
			if (graphview.graph.get(currentPos) instanceof Concatenate){
			str_highway += fsp.writeConcat(gestionWay.current, gestionWay.next)
			}else{
				str_highway += fsp.writeAdd(gestionWay.current, gestionWay.next)
			}
			currentPos++
		}
		gestionWay.removeLastFromList
		
		return str_highway
	}
	
	def gestionMergeBody(MergeBody mb, boolean isRecu) {
		var strMergeBody = ""
	
		//init merge
		gestionWay.add
		strMergeBody += fsp.writeInitMerge(gestionWay.current, gestionWay.next)
		
		// body merge (i.e Left & Right)
		strMergeBody += gestionLeft(mb.left,  isRecu)
		strMergeBody += '\n'
		strMergeBody += gestionRight(mb.right,  isRecu)
		
		// end merge (i.e Add/Concatenate)
		//if(graph.getByID(currentPos) instanceof Concatenate){
		if (graphview.graph.get(currentPos) instanceof Concatenate){
			strMergeBody += fsp.writeConcat(gestionWay.current, gestionWay.next)
		}else{
			strMergeBody += fsp.writeAdd(gestionWay.current, gestionWay.next)
		}
		currentPos++
		gestionWay.removeLastFromList
		
		return strMergeBody
	}
	
	def gestionLeft(Left left, boolean isRecu) {
		var strLeft = ""
		if (left.p !== null){
			strLeft += unitPooling(left.p, gestionWay.current)
		}
		
		if (left.com.convdrop !== null){
			for (convdrop: left.com.convdrop){
				strLeft += gestionConv(convdrop.conv, gestionWay.current)
				
				if(convdrop.drop !== null){
					strLeft += unitDropout(gestionWay.current)
				}
			}
		}
		
		if(left.com.mergeConv !== null){
			
			for(mc : left.com.mergeConv){
				
				strLeft += gestionMerge(mc.merge, true)
				
				if (mc.convdrop !== null){
					for (convdrop: mc.convdrop){
						strLeft += gestionConv(convdrop.conv, gestionWay.current)
						if(convdrop.drop !== null)
							strLeft += unitDropout(gestionWay.current)
						}
				}
			}
		}
		
		if (left.pool !== null){
			strLeft += unitPooling(left.pool, gestionWay.current)
		}
		
		return strLeft
	}
	
	def gestionRight(Right right, boolean isRecu) {
		var strRight = ""
		
		if(right.conv !== null){
			for (conv: right.conv){
				strRight += gestionConv(conv, gestionWay.next)
			}
		}
		
		return strRight
	}
	
	
	def gestionInter(Interstice inter) {
		var string_inter = ""
		
		if (inter.fg.flat !== null){
			string_inter += unitFlatten(gestionWay.current)
		}else{
			string_inter += unitGlobalPooling(inter.fg.gp, gestionWay.current)
		}
			
		return string_inter
	}
	
	def gestionDense(EList<Classification> list) {
		var strDense = ""
		
		for(i: list){
			if(i.drop !== null)
				strDense += unitDropout(gestionWay.current)
			strDense += unitDense(gestionWay.current)
		}
		
		return strDense
	}
	

	
	// ===== Units =====
	
	def unitConv(String X_or_shortcut){
		var Convolution conv = graphview.convolutionController.findByLayerpos(currentPos)
		//var Convolution conv = graph.getByID(currentPos) as Convolution
		// str_stride += conv.stride + " "
		currentPos++
		return fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fctActivation, conv.padding, X_or_shortcut)
	}
	
	def unitUpConv(String X_or_shortcut){
		return fsp.writeUpconv(X_or_shortcut, 2)
	}
	
	def unitBnConv(String X_or_shortcut){
		var BatchNormalisation bn = graphview.batchNormalisationController.findByLayerpos(currentPos)
		//var BatchNormalisation bn = graph.getByID(currentPos) as BatchNormalisation
		currentPos++
		
		var Convolution conv = graphview.convolutionController.findByLayerpos(currentPos)
		//var Convolution conv = graph.getByID(currentPos) as Convolution
		currentPos++
		// str_stride += conv.stride + " "
		
		return fsp.writeBN(bn.epsilon, X_or_shortcut) + fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fctActivation, conv.padding, X_or_shortcut)
	}
	
	def unitConvBn(String X_or_shortcut){
		var Convolution conv = graphview.convolutionController.findByLayerpos(currentPos)
		//var Convolution conv = graph.getByID(currentPos) as Convolution
		currentPos++
		
		var BatchNormalisation bn = graphview.batchNormalisationController.findByLayerpos(currentPos)
		//var BatchNormalisation bn = graph.getByID(currentPos) as BatchNormalisation
		currentPos++
		// str_stride += conv.stride + " "
		return fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fctActivation, conv.padding, X_or_shortcut) + fsp.writeBN(bn.epsilon, X_or_shortcut)
	}
	
	 
	def unitPooling(String pool, String X_or_shortcut){
		var Pooling p = graphview.poolingController.findByLayerpos(currentPos)
		//var Pooling p = graph.getByID(currentPos) as Pooling
		currentPos++
		if(pool == "avg_pooling"){
			return fsp.writeAvgPooling(p.kernel,p.stride,p.padding, X_or_shortcut)
		}else{
			return fsp.writeMaxPooling(p.kernel,p.stride,p.padding, X_or_shortcut)
		}
	}
	
	def unitDropout(String X_or_shortcut){
		var Dropout dropout = graphview.dropoutController.findByLayerpos(currentPos)
		//var Dropout dropout = graph.getByID(currentPos) as Dropout
		currentPos++;
		return fsp.writeDropout(dropout.dropoutRate, X_or_shortcut)
	}
	
	def unitDense(String X_or_shortcut){
		var Dense dense = graphview.denseController.findByLayerpos(currentPos)
		//var Dense dense = graph.getByID(currentPos) as Dense
		currentPos++
		return fsp.writeDense(dense.units,dense.fctActivation, X_or_shortcut)
	}
	
	def unitFlatten(String X_or_shortcut){
		currentPos++
		return fsp.writeFlatten(X_or_shortcut)
	}
	
	def unitGlobalPooling(String elem, String X_or_shortcut){
		currentPos++
		if(elem == "global_avg_pooling"){
			return fsp.writeGloAvgPooling(X_or_shortcut)	
		}else {
			return fsp.writeGloMaxPooling(X_or_shortcut)
		}
	}
		
	
}