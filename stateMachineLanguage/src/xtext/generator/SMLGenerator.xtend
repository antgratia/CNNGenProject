/*
 * generated by Xtext 2.25.0
 */
package xtext.generator

import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import utils.FonctionStringPy
import utils.GestionWay
import xtext.sML.Architecture
import xtext.sML.Classification
import xtext.sML.Convolution
import xtext.sML.FeatureExtraction
import xtext.sML.Interstice
import xtext.sML.LeftNonRecursive
import xtext.sML.LeftRecu
import xtext.sML.Merge
import xtext.sML.MergeNonRecu
import xtext.sML.MergeRecu
import xtext.sML.Right

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SMLGenerator extends AbstractGenerator {

	var fsp = new FonctionStringPy()
	
	var gestionWay = GestionWay.gestionWay;
	
	// python directory
    //var py_dir = "architecture_py/"
    
    // log directory
    var log_dir = "../architecture_log/"
    
    // png directory
    var png_dir = "../architecture_img/"
    
    var file_name = "architecture"
    

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		gestionWay = GestionWay.gestionWay
		for(elem : resource.allContents.toIterable.filter(Architecture)){
			fsa.generateFile('architecture.py', elem.compile())
		}
	}
	
	
	private def compile(Architecture archi ){
		var py_file = ""
		
		// write import
		py_file += fsp.strImport()
		
		// write dataset 
		py_file += fsp.writeMnistDataSet()
		
		// write init value 
		py_file += fsp.writeInitValue()
		
		println(archi)
		
		// try	
    	py_file += "try:\n"
		
		py_file += gestionArchi(archi)
		
		py_file += fsp.writeTrain()
		
		py_file += fsp.gestionGood(log_dir, file_name)
		
		py_file += fsp.gestionError(log_dir, file_name)
		
		py_file += fsp.gestionFinally(file_name)
		
		
		return py_file
		
	}
	
	private def gestionArchi(Architecture a){
		var str_archi = "\tdef getModel():\n"
		
		// verify input not missing
		if (!a.input.empty){
			str_archi += fsp.writeInput("[28, 28, 1]", gestionWay.current)
		}else{
			throw new Exception("missing Input")
		}
		
		// verify feature extraction not missing
		if (!a.fe.empty){
			str_archi += gestionFE(a.fe)
			//println(a.fe)

		}else{
			throw new Exception("missing feature extra")
		}

		
		if (a.inter !== null && a.class_ !== null){
			str_archi += gestionInter(a.inter)
			str_archi += gestionDense(a.class_)
		}
		
		
		if(!a.output.empty){
			str_archi += String.format("\t\tmodel = Model(inputs=X_input, outputs=%s)\n", gestionWay.current)
			str_archi += "\t\treturn model\n\n"
			str_archi += "\tmodel = getModel()\n"
			
			// write : create png of the model
    		str_archi += String.format("\tplot_model(model, show_shapes=True, to_file=\"%s\")\n", 
    			png_dir+file_name+".png"
    		)
    		// write compiler
    		str_archi += "\tmodel.compile(optimizer='adam', loss=keras.losses.sparse_categorical_crossentropy, metrics=['accuracy'])\n\n"
    		
		}else{
			throw new Exception("missing output")
		}
		
		return str_archi
	}
	
	def gestionFE(EList<FeatureExtraction> list) {
		var fe_string = ""
		for (elem: list){
			if (elem.conv !== null){
				fe_string += gestionConv(elem.conv, gestionWay.current)
			}else if (elem.merge !== null){
				fe_string += gestionMerge(elem.merge)
			}else {
				// TODO HW
				//fe_string += 
			}
			
			if (elem.drop !== null)
				fe_string += unitDropout(gestionWay.current)
			if (elem.pool !== null)
				fe_string += unitPooling(elem.pool, gestionWay.current)
		}
		return	fe_string
	}
	
	
	def gestionConv(Convolution conv, String x_or_shortcut) {
		if( conv.bnconv !== null)
			return unitBnConv(x_or_shortcut)
		else if (conv.convbn !== null)
			return unitConvBn(x_or_shortcut)
		else if (conv.conv !== null)
			return unitConv(x_or_shortcut)
		else return unitUpConv(x_or_shortcut)
	}
	
	def gestionMerge(Merge merge) {
		var str_merge = ""
		if(merge.mnr !== null) str_merge += gestionMergeNonRecu(merge.mnr)
		else str_merge += gestionMergeRecu(merge.mr)
	}
	
	def gestionMergeNonRecu(MergeNonRecu mergeNonRecu) {
		var strMergeNonRecur = ""
	
		//init merge
		gestionWay.add
		strMergeNonRecur += fsp.writeInitMerge(gestionWay.current, gestionWay.next)
		
		// body merge (i.e Left & Right)
		strMergeNonRecur += gestionLeftNonRecursive(mergeNonRecu.leftNonRec)
		strMergeNonRecur += '\n'
		strMergeNonRecur += gestionRight(mergeNonRecu.right)
		
		// end merge (i.e Add/Concatenate)
		strMergeNonRecur += fsp.writeConcat(gestionWay.current, gestionWay.next)
		gestionWay.removeLastFromList
		
		return strMergeNonRecur
	}
	
	def gestionLeftNonRecursive(LeftNonRecursive left) {
		var strLeft = ""
		if (left.p !== null){
			strLeft += unitPooling(left.p, gestionWay.current)
		}
		
		if(left.convdrop !== null){
			for (convdrop: left.convdrop){
				strLeft += gestionConv(convdrop.conv, gestionWay.current)
				if(convdrop.drop !== null)
					strLeft += unitDropout(gestionWay.current)
			}
		}
		return strLeft
	}
	
	def gestionRight(Right right) {
		var strRight = ""
		
		if(right.conv !== null){
			for (conv: right.conv){
				strRight += gestionConv(conv, gestionWay.next)
			}
		}
		
		return strRight
	}
	
	def gestionMergeRecu(MergeRecu mergeRecu) {
		var strMerge =""

		
		//init merge
		gestionWay.add
		strMerge += fsp.writeInitMerge(gestionWay.current, gestionWay.next)
		
		//body
		strMerge += gestionLeftRecursive(mergeRecu.left)
		strMerge += '\n'
		strMerge += gestionRight(mergeRecu.right)
		
		// end

		strMerge += fsp.writeConcat(gestionWay.next, gestionWay.current)
		gestionWay.removeBeforeLastFromList
		
		
			
		return strMerge
	}
	
	
	def gestionLeftRecursive(LeftRecu left) {
		var strLeftRecu = ""
		
		if(left.p !== null)
			strLeftRecu += unitPooling(left.p, gestionWay.next)
		
		if (left.convdropbegin !== null){
			for (convdrop: left.convdropbegin){
				strLeftRecu += gestionConv(convdrop.conv, gestionWay.next)
				if(convdrop.drop !== null)
					strLeftRecu += unitDropout(gestionWay.next)
			}
		}
		
		strLeftRecu += gestionMerge(left.merge)
		
		if (left.convdropend !== null){
			for (convdrop: left.convdropend){
				strLeftRecu += gestionConv(convdrop.conv, gestionWay.next)
				if(convdrop.drop !== null)
					strLeftRecu += unitDropout(gestionWay.next)
			}
		}
		
		if(left.pool !== null)
			strLeftRecu += unitPooling(left.p, gestionWay.next)

		
		return strLeftRecu
	}
	
	def gestionDense(EList<Classification> list) {
		var strDense = ""
		for (dense: list){
			strDense += unitDense(gestionWay.current)
			if(dense.drop !== null)
				strDense += unitDropout(gestionWay.current)
		}
		return strDense
	}
	
	def gestionInter(Interstice inter) {
		var string_inter = ""
		
		if (inter.fg.flat !== null){
			string_inter += unitFlatten(gestionWay.current)
		}else{
			string_inter += unitGlobalPooling(inter.fg.gp, gestionWay.current)
		}
		
		if(inter.drop !== null)
			string_inter += unitDropout(gestionWay.current)
			
		return string_inter
	}
	
	
	
	def unitConv(String X_or_shortcut){
		var models.Convolution conv = new models.Convolution
		conv = conv.hyperparameters as models.Convolution
		return fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fct_activation, conv.padding, X_or_shortcut)
	}
	
	def unitUpConv(String X_or_shortcut){
		return fsp.writeUpconv(X_or_shortcut, 2)
	}
	
	def unitBnConv(String X_or_shortcut){
		return fsp.writeBN(0.2, X_or_shortcut) + fsp.writeConv(10,1,1,"relu","same", X_or_shortcut)
	}
	
	def unitConvBn(String X_or_shortcut){
		return fsp.writeConv(10,1,1,"relu","same",X_or_shortcut) + fsp.writeBN(0.2, X_or_shortcut)
	}
	
	def unitPooling(String pool, String X_or_shortcut){
		if(pool == "avg_pooling"){
			return fsp.writeAvgPooling(1,1,"same", X_or_shortcut)
		}else{
			return fsp.writeMaxPooling(1,1,"same", X_or_shortcut)
		}
	}
	
	def unitDropout(String X_or_shortcut){
		return fsp.writeDropout(0.5, X_or_shortcut)
	}
	
	def unitDense(String X_or_shortcut){
		return fsp.writeDense(50,"relu", X_or_shortcut)
	}
	
	def unitFlatten(String X_or_shortcut){
		return fsp.writeFlatten(X_or_shortcut)
	}
	
	def unitGlobalPooling(String elem, String X_or_shortcut){
		if(elem == "global_avg_pooling"){
			return fsp.writeGloAvgPooling(X_or_shortcut)	
		}else {
			return fsp.writeGloMaxPooling(X_or_shortcut)
		}
	}
	
	

		
	
}