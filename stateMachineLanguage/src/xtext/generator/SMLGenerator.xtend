/*
 * generated by Xtext 2.25.0
 */
package xtext.generator

import models.BatchNormalisation
import models.Convolution
import models.Dense
import models.Dropout
import models.MergeSimple
import models.Pooling
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import utils.FonctionStringPy
import utils.GestionWay
import xtext.sML.Architecture
import xtext.sML.Classification
import xtext.sML.FeatureExtraction
import xtext.sML.Interstice
import xtext.sML.LeftNonRecursive
import xtext.sML.LeftRecu
import xtext.sML.Merge
import xtext.sML.MergeNonRecu
import xtext.sML.MergeRecu
import xtext.sML.Right
import utils.GestionHpp

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SMLGenerator extends AbstractGenerator {

	var fsp = new FonctionStringPy()
	
	var gestionWay = GestionWay.gestionWay;
	
	// python directory
    var py_dir = "architecture_py/"
    
    // log directory
    var log_dir = "../architecture_log/"
    
    // png directory
    var png_dir = "../architecture_img/"
    
    var file_name = "architecture"
    

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		gestionWay = GestionWay.gestionWay
		GestionHpp.destroy
		for(elem : resource.allContents.toIterable.filter(Architecture)){
			fsa.generateFile(py_dir + file_name + '.py', elem.compile())
		}
	}
	
	
	private def compile(Architecture archi ){
		var py_file = ""
		
		// write import
		py_file += fsp.strImport()
		
		// write dataset 
		py_file += fsp.writeMnistDataSet()
		
		// write init value 
		py_file += fsp.writeInitValue()
		
		println(archi)
		
		// try	
    	py_file += "try:\n"
		
		py_file += gestionArchi(archi)
		
		py_file += fsp.writeTrain()
		
		py_file += fsp.gestionGood(log_dir, file_name)
		
		py_file += fsp.gestionError(log_dir, file_name)
		
		py_file += fsp.gestionFinally(file_name)
		
		
		return py_file
		
	}
	
	private def gestionArchi(Architecture a){
		var str_archi = "\tdef getModel():\n"
		
		// verify input not missing
		if (!a.input.empty){
			str_archi += fsp.writeInput("[28, 28, 1]", gestionWay.current)
		}else{
			throw new Exception("missing Input")
		}
		
		// verify feature extraction not missing
		if (!a.fe.empty){
			str_archi += gestionFE(a.fe)
			//println(a.fe)

		}else{
			throw new Exception("missing feature extra")
		}

		
		if (a.inter !== null && a.class_ !== null){
			str_archi += gestionInter(a.inter)
			str_archi += gestionDense(a.class_)
		}
		
		
		if(!a.output.empty){
			str_archi += String.format("\t\tmodel = Model(inputs=X_input, outputs=%s)\n", gestionWay.current)
			str_archi += "\t\treturn model\n\n"
			str_archi += "\tmodel = getModel()\n"
			
			// write : create png of the model
    		str_archi += String.format("\tplot_model(model, show_shapes=True, to_file=\"%s\")\n", 
    			png_dir+file_name+".png"
    		)
    		// write compiler
    		str_archi += "\tmodel.compile(optimizer='adam', loss=keras.losses.sparse_categorical_crossentropy, metrics=['accuracy'])\n\n"
    		
		}else{
			throw new Exception("missing output")
		}
		
		return str_archi
	}
	
	def gestionFE(EList<FeatureExtraction> list) {
		var fe_string = ""
		for (elem: list){
			if (elem.conv !== null){
				fe_string += gestionConv(elem.conv, gestionWay.current)
			}else if (elem.merge !== null){
				fe_string += gestionMerge(elem.merge)
			}else {
				// TODO HW
				//fe_string += 
			}
			
			if (elem.drop !== null)
				fe_string += unitDropout(gestionWay.current)
			if (elem.pool !== null)
				fe_string += unitPooling(elem.pool, gestionWay.current)
		}
		return	fe_string
	}
	
	
	def gestionConv(xtext.sML.Convolution conv, String x_or_shortcut) {
		if( conv.bnconv !== null)
			return unitBnConv(x_or_shortcut)
		else if (conv.convbn !== null)
			return unitConvBn(x_or_shortcut)
		else if (conv.conv !== null)
			return unitConv(x_or_shortcut)
		else return unitUpConv(x_or_shortcut)
	}
	
	def gestionConv(xtext.sML.Convolution conv, String x_or_shortcut, Convolution hppConv) {
		if( conv.bnconv !== null)
			return unitBnConv(x_or_shortcut, hppConv)
		else if (conv.convbn !== null)
			return unitConvBn(x_or_shortcut, hppConv)
		else if (conv.conv !== null)
			return unitConv(x_or_shortcut, hppConv)
		else return unitUpConv(x_or_shortcut)
	}
	
	def gestionMerge(Merge merge) {
		var str_merge = ""
		if(merge.mnr !== null) str_merge += gestionMergeNonRecu(merge.mnr)
		else str_merge += gestionMergeRecu(merge.mr)
	}
	
	def gestionMergeNonRecu(MergeNonRecu mergeNonRecu) {
		var MergeSimple merge = new MergeSimple(mergeNonRecu);
		var strMergeNonRecur = ""
	
		//init merge
		gestionWay.add
		strMergeNonRecur += fsp.writeInitMerge(gestionWay.current, gestionWay.next)
		
		// body merge (i.e Left & Right)
		strMergeNonRecur += gestionLeftNonRecursive(mergeNonRecu.leftNonRec, merge)
		strMergeNonRecur += '\n'
		strMergeNonRecur += gestionRight(mergeNonRecu.right, merge)
		
		// end merge (i.e Add/Concatenate)
		if (merge.add_or_concat == 'concat'){
			strMergeNonRecur += fsp.writeConcat(gestionWay.current, gestionWay.next)
		}else{
			strMergeNonRecur += fsp.writeAdd(gestionWay.current, gestionWay.next)
		}
		gestionWay.removeLastFromList
		
		return strMergeNonRecur
	}
	
	def gestionLeftNonRecursive(LeftNonRecursive left, MergeSimple merge) {
		var strLeft = ""
		if (left.p !== null){
			strLeft += unitPooling(left.p, gestionWay.current, merge.left.get(0) as Pooling)
			merge.removeFirstLeft
		}
		
		if(left.convdrop !== null){
			for (convdrop: left.convdrop){
				strLeft += gestionConv(convdrop.conv, gestionWay.current, merge.left.get(0) as Convolution)
				merge.removeFirstLeft
				if(convdrop.drop !== null)
					strLeft += unitDropout(gestionWay.current)
			}
		}
		
		if (left.pool !== null){
			strLeft += unitPooling(left.pool, gestionWay.current, merge.left.get(0) as Pooling)
			merge.removeFirstLeft
		}
		
		return strLeft
	}
	
	def gestionRight(Right right, MergeSimple merge) {
		var strRight = ""
		
		if(right.conv !== null){
			for (conv: right.conv){
				strRight += gestionConv(conv, gestionWay.next, merge.right.get(0) as Convolution)
				merge.removeFirstRight
			}
		}
		
		return strRight
	}
	
	def gestionMergeRecu(MergeRecu mergeRecu) {
		var MergeSimple ms = new MergeSimple(mergeRecu)
		var strMerge =""

		
		//init merge
		gestionWay.add
		strMerge += fsp.writeInitMerge(gestionWay.current, gestionWay.next)
		
		//body
		strMerge += gestionLeftRecursive(mergeRecu.left, ms)
		strMerge += '\n'
		strMerge += gestionRight(mergeRecu.right, ms)
		
		// end

		strMerge += fsp.writeConcat(gestionWay.next, gestionWay.current)
		gestionWay.removeBeforeLastFromList
		
		
			
		return strMerge
	}
	
	
	def gestionLeftRecursive(LeftRecu left, MergeSimple ms) {
		var strLeftRecu = ""
		
		if(left.p !== null)
			strLeftRecu += unitPooling(left.p, gestionWay.next)
		
		if (left.convdropbegin !== null){
			for (convdrop: left.convdropbegin){
				strLeftRecu += gestionConv(convdrop.conv, gestionWay.next)
				if(convdrop.drop !== null)
					strLeftRecu += unitDropout(gestionWay.next)
			}
		}
		
		strLeftRecu += gestionMerge(left.merge)
		
		if (left.convdropend !== null){
			for (convdrop: left.convdropend){
				strLeftRecu += gestionConv(convdrop.conv, gestionWay.next)
				if(convdrop.drop !== null)
					strLeftRecu += unitDropout(gestionWay.next)
			}
		}
		
		if(left.pool !== null)
			strLeftRecu += unitPooling(left.p, gestionWay.next)

		
		return strLeftRecu
	}
	
	def gestionInter(Interstice inter) {
		var string_inter = ""
		
		if (inter.fg.flat !== null){
			string_inter += unitFlatten(gestionWay.current)
		}else{
			string_inter += unitGlobalPooling(inter.fg.gp, gestionWay.current)
		}
			
		return string_inter
	}
	
	def gestionDense(EList<Classification> list) {
		var strDense = ""
		var i = 0; 
		while (i<list.size()-1){
			if(list.get(i).drop !== null)
				strDense += unitDropout(gestionWay.current)
			strDense += unitDense(gestionWay.current, false)
			i++;
		}
		
		if(list.get(i).drop !== null)
				strDense += unitDropout(gestionWay.current)
		strDense += unitDense(gestionWay.current, true);
		
		return strDense
	}
	

	
	// ===== Units =====
	
	def unitConv(String X_or_shortcut){
		var Convolution conv = new Convolution
		conv.hyperparameters
		return fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fct_activation, conv.padding, X_or_shortcut)
	}
	
	def unitConv(String X_or_shortcut, Convolution conv){
		return fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fct_activation, conv.padding, X_or_shortcut)
	}
	
	def unitUpConv(String X_or_shortcut){
		return fsp.writeUpconv(X_or_shortcut, 2)
	}
	
	def unitBnConv(String X_or_shortcut){
		var BatchNormalisation bn = new BatchNormalisation
		bn.hyperparameters
		
		var Convolution conv = new Convolution
		conv.hyperparameters
		
		return fsp.writeBN(bn.epsilon, X_or_shortcut) + fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fct_activation, conv.padding, X_or_shortcut)
	}
	
	def unitBnConv(String X_or_shortcut, Convolution conv){
		var BatchNormalisation bn = new BatchNormalisation
		bn.hyperparameters
		
		return fsp.writeBN(bn.epsilon, X_or_shortcut) + fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fct_activation, conv.padding, X_or_shortcut)
	}
	
	def unitConvBn(String X_or_shortcut){
		var BatchNormalisation bn = new BatchNormalisation
		bn.hyperparameters
		
		var Convolution conv = new Convolution
		conv.hyperparameters
		
		return fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fct_activation, conv.padding, X_or_shortcut) + fsp.writeBN(bn.epsilon, X_or_shortcut)
	}
	
	def unitConvBn(String X_or_shortcut, Convolution conv){
		var BatchNormalisation bn = new BatchNormalisation
		bn.hyperparameters
		
		return fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fct_activation, conv.padding, X_or_shortcut) + fsp.writeBN(bn.epsilon, X_or_shortcut)
	}
	
	def unitPooling(String pool, String X_or_shortcut){
		var Pooling p = new Pooling
		p.hyperparameters
		if(pool == "avg_pooling"){
			return fsp.writeAvgPooling(p.kernel,p.stride,p.padding, X_or_shortcut)
		}else{
			return fsp.writeMaxPooling(p.kernel,p.stride,p.padding, X_or_shortcut)
		}
	}
	
		def unitPooling(String pool, String X_or_shortcut, Pooling p){
		if(pool == "avg_pooling"){
			return fsp.writeAvgPooling(p.kernel,p.stride,p.padding, X_or_shortcut)
		}else{
			return fsp.writeMaxPooling(p.kernel,p.stride,p.padding, X_or_shortcut)
		}
	}
	
	def unitDropout(String X_or_shortcut){
		var Dropout dropout = new Dropout
		dropout.hyperparameters
		return fsp.writeDropout(dropout.dropoutRate, X_or_shortcut)
	}
	
	def unitDense(String X_or_shortcut, boolean last){
		var Dense dense = new Dense(last)
		dense.hyperparameters
		return fsp.writeDense(dense.units,dense.fctActivation, X_or_shortcut)
	}
	
	def unitFlatten(String X_or_shortcut){
		return fsp.writeFlatten(X_or_shortcut)
	}
	
	def unitGlobalPooling(String elem, String X_or_shortcut){
		if(elem == "global_avg_pooling"){
			return fsp.writeGloAvgPooling(X_or_shortcut)	
		}else {
			return fsp.writeGloMaxPooling(X_or_shortcut)
		}
	}
	
	

		
	
}