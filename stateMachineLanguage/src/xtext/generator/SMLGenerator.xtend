/*
 * generated by Xtext 2.25.0
 */
package xtext.generator

import controller.MainController
import domain.BatchNormalisation
import domain.Concatenate
import domain.Convolution
import domain.Dense
import domain.Dropout
import domain.Pooling
import java.io.PrintWriter
import models.ArchitectureGraph
import models.MergeSimple
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import utils.FonctionStringPy
import utils.GestionWay
import xtext.sML.Architecture
import xtext.sML.Classification
import xtext.sML.FeatureExtraction
import xtext.sML.Interstice
import xtext.sML.Left
import xtext.sML.Merge
import xtext.sML.MergeBody
import xtext.sML.Right
import xtext.sML.SML

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SMLGenerator extends AbstractGenerator {

	var fsp = new FonctionStringPy()
	
	var GestionWay gestionWay = null //GestionWay.gestionWay
	
	MainController mainCtrl = null
	
	ArchitectureGraph graph = null
	var currentPos = 1
		
	// python directory
    var py_dir = "architecture_py/"
    
   	/*
   	 * 
   	 * USING GENERATOR
   	 * 
   	 * 
   	 * */
   	
    // log directory
    var log_dir = "../../architecture_log/"
    
    // png directory
    var png_dir = "../../architecture_img/"
    
       // csv directory
    static String csvDir = "../../architecture_csv/";
    
    
    /*
     * 
     * USING MANUAL CONSTRUCTION
     * 
     */
    /*
    // log directory
    var log_dir = "../architecture_log/"
    
    // png directory
    var png_dir = "../architecture_img/"
    
    // csv directory
    static String csvDir = "../architecture_csv/";
     */
    
    
	var file_name = ""
	
	var exp_dir = ""
	
	//var str_stride = ""
    
	// entry for ui
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		println(resource.URI)
		file_name = "architecture"
		for(elem : resource.allContents.toIterable.filter(Architecture)){
			fsa.generateFile(py_dir + file_name + '.py', elem.compile())
		}
	}
	
	// entry for generator
	def String generate(SML sml, String filename, String expDir) {		
	
		exp_dir = expDir
		file_name = filename.split("/").get(3).split('.py').get(0)
		
		//println("smlgenerator:  " + sml.sml)
		var archi = compile(sml.sml)
		//println(archi)
		
		var writer = new PrintWriter(filename, "UTF-8");
		writer.println(archi);
		writer.close();
		return "" // str_stride
	}
	
	
	private def compile(Architecture archi ){
		
		currentPos = 1
		mainCtrl = new MainController()
		gestionWay = mainCtrl.gestionWay
		
		mainCtrl.createGraph(archi)
	
		
		graph = mainCtrl.graph
		
		/*println("\n\n")
		for(i: graph.graph.entrySet){
			
			println(i)
			println("\n")
		}*/
		

				
		mainCtrl.getGraphHyperparameters
		
		println("\n\n")
		for(i: graph.graph.entrySet){
			
			println(i)
			println("\n")
		}
		


		var py_file = ""
		
		
		// write import
		py_file += fsp.strImport()
		
		
		// write dataset minist
		//py_file += fsp.writeMnistDataSet()
		
		// write dataset cifar10
		py_file += fsp.writecifar10Dataset
				
		// write init value 
		py_file += fsp.writeInitValue()
		
		//println(archi)
		
		// try	
    	py_file += "try:\n"
		
		
		py_file += gestionArchi(archi)
		
		
		py_file += fsp.writeTrain()
		
		py_file += fsp.gestionGood(log_dir + exp_dir, file_name)
		
		py_file += fsp.gestionError(log_dir + exp_dir, file_name)
		
		py_file += fsp.gestionFinally(csvDir + exp_dir, file_name)
		
		
		return py_file
		
	}
	
	private def gestionArchi(Architecture a){
		var str_archi = "\tdef getModel():\n"
		
		// verify input not missing
		if (!a.input.empty){
			str_archi += fsp.writeInput("[32, 32, 3]", gestionWay.current)
		}else{
			throw new Exception("missing Input")
		}
		
		// verify feature extraction not missing
		if (!a.fe.empty){
			str_archi += gestionFE(a.fe)
			//println(a.fe)

		}else{
			throw new Exception("missing feature extra")
		}

		
		if (a.inter !== null && a.class_ !== null){
			str_archi += gestionInter(a.inter)
			str_archi += gestionDense(a.class_)
		}
		
		
		if(!a.output.empty){
			str_archi += String.format("\t\tmodel = Model(inputs=X_input, outputs=%s)\n", gestionWay.current)
			str_archi += "\t\treturn model\n\n"
			str_archi += "\tmodel = getModel()\n"
			
			// write : create png of the model
    		str_archi += String.format("\tplot_model(model, show_shapes=True, to_file=\"%s\")\n", 
    			png_dir+exp_dir+file_name+".png"
    		)
    		// write compiler
    		str_archi += "\tmodel.compile(optimizer='adam', loss=keras.losses.sparse_categorical_crossentropy, metrics=['accuracy'])\n\n"
    		
		}else{
			throw new Exception("missing output")
		}
		
		return str_archi
	}
	
	def gestionFE(EList<FeatureExtraction> list) {
		var fe_string = ""
		for (elem: list){
			if (elem.conv !== null){
				fe_string += gestionConv(elem.conv, gestionWay.current)

			}else if (elem.merge !== null){
				var MergeSimple ms = null
				fe_string += gestionMerge(elem.merge, ms, true)
				ms = null
			}else {
				throw new Exception("gestionFe errors")
			}
			
			if (elem.drop !== null)
				fe_string += unitDropout(gestionWay.current)
			if (elem.pool !== null)
				fe_string += unitPooling(elem.pool, gestionWay.current)
		}
		return	fe_string
	}
	
	
	def gestionConv(xtext.sML.Convolution conv, String x_or_shortcut) {
		if( conv.bnconv !== null)
			return unitBnConv(x_or_shortcut)
		else if (conv.convbn !== null)
			return unitConvBn(x_or_shortcut)
		else if (conv.conv !== null)
			return unitConv(x_or_shortcut)
		else return unitUpConv(x_or_shortcut)
	}
	
	def gestionMerge(Merge merge, MergeSimple mergeSimple, boolean isRecu) {
		var str_merge = ""
		var ms = mergeSimple
		
		if(merge.mergeBody.size <= 1){
			if(ms === null){
				ms = new MergeSimple(merge)
			}
			
			str_merge += gestionMergeBody(merge.mergeBody.get(0), ms, isRecu)
		}else {
			if(ms === null){
				ms = new MergeSimple(merge.mergeBody)
			}
			str_merge += gestionHighway(merge.mergeBody, ms, isRecu)
		}
		
		return str_merge
	}
	
	def gestionHighway(EList<MergeBody> listMerge, MergeSimple merge, boolean isRecu) {
		var str_highway = ""
		
		//init merge
		gestionWay.add
		str_highway += fsp.writeInitMerge(gestionWay.current, gestionWay.next)
		
		for (mb: listMerge){	
			// body merge (i.e Left & Right)
			str_highway += gestionLeft(mb.left, merge, false)
			str_highway += '\n'
			str_highway += gestionRight(mb.right, merge, false)
			
			// end merge (i.e Add/Concatenate)
			if (graph.getByID(currentPos) instanceof Concatenate){
			str_highway += fsp.writeConcat(gestionWay.current, gestionWay.next)
			}else{
				str_highway += fsp.writeAdd(gestionWay.current, gestionWay.next)
			}
			currentPos++
		}
		gestionWay.removeLastFromList
		
		return str_highway
	}
	
	def gestionMergeBody(MergeBody mb, MergeSimple merge, boolean isRecu) {
		var strMergeBody = ""
	
		//init merge
		gestionWay.add
		strMergeBody += fsp.writeInitMerge(gestionWay.current, gestionWay.next)
		
		// body merge (i.e Left & Right)
		strMergeBody += gestionLeft(mb.left, merge, isRecu)
		strMergeBody += '\n'
		strMergeBody += gestionRight(mb.right, merge, isRecu)
		
		// end merge (i.e Add/Concatenate)
		if (graph.getByID(currentPos) instanceof Concatenate){
			strMergeBody += fsp.writeConcat(gestionWay.current, gestionWay.next)
		}else{
			strMergeBody += fsp.writeAdd(gestionWay.current, gestionWay.next)
		}
		currentPos++
		gestionWay.removeLastFromList
		
		return strMergeBody
	}
	
	def gestionLeft(Left left, MergeSimple merge, boolean isRecu) {
		var strLeft = ""
		if (left.p !== null){
			if(isRecu) strLeft += unitPooling(left.p, gestionWay.next)
			else strLeft += unitPooling(left.p, gestionWay.current)
			merge.removeFirstLeft
		}
		
		if (left.com.convdrop !== null){
			for (convdrop: left.com.convdrop){
				/*if(isRecu) strLeft += gestionConv(convdrop.conv, gestionWay.next, merge.left.get(0) as Convolution)
				else strLeft += gestionConv(convdrop.conv, gestionWay.current, merge.left.get(0) as Convolution)*/
				
				if(isRecu) strLeft += gestionConv(convdrop.conv, gestionWay.next)
				else strLeft += gestionConv(convdrop.conv, gestionWay.current)
				
				merge.removeFirstLeft
				if(convdrop.drop !== null){
					if(isRecu) strLeft += unitDropout(gestionWay.next)
					else strLeft += unitDropout(gestionWay.current)
				}
			}
		}
		
		if(left.com.mergeConv !== null){
			
			for(mc : left.com.mergeConv){
				
				strLeft += gestionMerge(mc.merge, merge, true)
				
				if (mc.convdrop !== null){
					for (convdrop: mc.convdrop){
					/*if(isRecu) strLeft += gestionConv(convdrop.conv, gestionWay.next, merge.left.get(0) as Convolution)
					else strLeft += gestionConv(convdrop.conv, gestionWay.current, merge.left.get(0) as Convolution)*/
				
					if(isRecu) strLeft += gestionConv(convdrop.conv, gestionWay.next)
					else strLeft += gestionConv(convdrop.conv, gestionWay.current)
						merge.removeFirstLeft
						if(convdrop.drop !== null)
							if(isRecu)strLeft += unitDropout(gestionWay.next)
							else strLeft += unitDropout(gestionWay.current)
						}
				}
			}
		}
		
		if (left.pool !== null){
			if(isRecu) strLeft += unitPooling(left.pool, gestionWay.next)
			else strLeft += unitPooling(left.pool, gestionWay.current)
			merge.removeFirstLeft
		}
		
		return strLeft
	}
	
	def gestionRight(Right right, MergeSimple merge, boolean isRecu) {
		var strRight = ""
		
		if(right.conv !== null){
			for (conv: right.conv){
				/*if (isRecu)strRight += gestionConv(conv, gestionWay.current, merge.right.get(0) as Convolution)
				else strRight += gestionConv(conv, gestionWay.next, merge.right.get(0) as Convolution)*/
				if (isRecu)strRight += gestionConv(conv, gestionWay.current)
				else strRight += gestionConv(conv, gestionWay.next)
				merge.removeFirstRight
			}
		}
		
		return strRight
	}
	
	
	def gestionInter(Interstice inter) {
		var string_inter = ""
		
		if (inter.fg.flat !== null){
			string_inter += unitFlatten(gestionWay.current)
		}else{
			string_inter += unitGlobalPooling(inter.fg.gp, gestionWay.current)
		}
			
		return string_inter
	}
	
	def gestionDense(EList<Classification> list) {
		var strDense = ""
		
		for(i: list){
			if(i.drop !== null)
				strDense += unitDropout(gestionWay.current)
			strDense += unitDense(gestionWay.current)
		}
		
		return strDense
	}
	

	
	// ===== Units =====
	
	def unitConv(String X_or_shortcut){
		var Convolution conv = graph.getByID(currentPos) as Convolution
		// str_stride += conv.stride + " "
		currentPos++
		return fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fct_activation, conv.padding, X_or_shortcut)
	}
	
	def unitUpConv(String X_or_shortcut){
		return fsp.writeUpconv(X_or_shortcut, 2)
	}
	
	def unitBnConv(String X_or_shortcut){
		var BatchNormalisation bn = graph.getByID(currentPos) as BatchNormalisation
		currentPos++
		
		var Convolution conv = graph.getByID(currentPos) as Convolution
		currentPos++
		// str_stride += conv.stride + " "
		
		return fsp.writeBN(bn.epsilon, X_or_shortcut) + fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fct_activation, conv.padding, X_or_shortcut)
	}
	
	def unitConvBn(String X_or_shortcut){
		
		var Convolution conv = graph.getByID(currentPos) as Convolution
		currentPos++
		
		var BatchNormalisation bn = graph.getByID(currentPos) as BatchNormalisation
		currentPos++
		// str_stride += conv.stride + " "
		return fsp.writeConv(conv.nbFilter, conv.kernel, conv.stride , conv.fct_activation, conv.padding, X_or_shortcut) + fsp.writeBN(bn.epsilon, X_or_shortcut)
	}
	
	 
	def unitPooling(String pool, String X_or_shortcut){
		var Pooling p = graph.getByID(currentPos) as Pooling
		currentPos++
		if(pool == "avg_pooling"){
			return fsp.writeAvgPooling(p.kernel,p.stride,p.padding, X_or_shortcut)
		}else{
			return fsp.writeMaxPooling(p.kernel,p.stride,p.padding, X_or_shortcut)
		}
	}
	
	def unitDropout(String X_or_shortcut){
		var Dropout dropout = graph.getByID(currentPos) as Dropout
		currentPos++;
		return fsp.writeDropout(dropout.dropoutRate, X_or_shortcut)
	}
	
	def unitDense(String X_or_shortcut){
		var Dense dense = graph.getByID(currentPos) as Dense
		currentPos++
		return fsp.writeDense(dense.units,dense.fctActivation, X_or_shortcut)
	}
	
	def unitFlatten(String X_or_shortcut){
		currentPos++
		return fsp.writeFlatten(X_or_shortcut)
	}
	
	def unitGlobalPooling(String elem, String X_or_shortcut){
		currentPos++
		if(elem == "global_avg_pooling"){
			return fsp.writeGloAvgPooling(X_or_shortcut)	
		}else {
			return fsp.writeGloMaxPooling(X_or_shortcut)
		}
	}
		
	
}