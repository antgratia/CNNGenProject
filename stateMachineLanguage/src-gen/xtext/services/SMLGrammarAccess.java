/*
 * generated by Xtext 2.26.0
 */
package xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SMLGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class SMLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.SML");
		private final Assignment cSmlAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cSmlArchitectureParserRuleCall_0 = (RuleCall)cSmlAssignment.eContents().get(0);
		
		//SML : sml = (Architecture);
		@Override public ParserRule getRule() { return rule; }
		
		//sml = (Architecture)
		public Assignment getSmlAssignment() { return cSmlAssignment; }
		
		//(Architecture)
		public RuleCall getSmlArchitectureParserRuleCall_0() { return cSmlArchitectureParserRuleCall_0; }
	}
	public class ArchitectureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Architecture");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInputAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInputInputKeyword_0_0 = (Keyword)cInputAssignment_0.eContents().get(0);
		private final Assignment cFeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFeFeatureExtractionParserRuleCall_1_0 = (RuleCall)cFeAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cInterAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cInterIntersticeParserRuleCall_2_0_0 = (RuleCall)cInterAssignment_2_0.eContents().get(0);
		private final Assignment cClassAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cClassClassificationParserRuleCall_2_1_0 = (RuleCall)cClassAssignment_2_1.eContents().get(0);
		private final Assignment cOutputAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cOutputOutputKeyword_3_0 = (Keyword)cOutputAssignment_3.eContents().get(0);
		
		//Architecture : input = ('input') fe += (FeatureExtraction)+ (inter = (Interstice) class += (Classification)+)? output = ('output');
		@Override public ParserRule getRule() { return rule; }
		
		//input = ('input') fe += (FeatureExtraction)+ (inter = (Interstice) class += (Classification)+)? output = ('output')
		public Group getGroup() { return cGroup; }
		
		//input = ('input')
		public Assignment getInputAssignment_0() { return cInputAssignment_0; }
		
		//('input')
		public Keyword getInputInputKeyword_0_0() { return cInputInputKeyword_0_0; }
		
		//fe += (FeatureExtraction)+
		public Assignment getFeAssignment_1() { return cFeAssignment_1; }
		
		//(FeatureExtraction)
		public RuleCall getFeFeatureExtractionParserRuleCall_1_0() { return cFeFeatureExtractionParserRuleCall_1_0; }
		
		//(inter = (Interstice) class += (Classification)+)?
		public Group getGroup_2() { return cGroup_2; }
		
		//inter = (Interstice)
		public Assignment getInterAssignment_2_0() { return cInterAssignment_2_0; }
		
		//(Interstice)
		public RuleCall getInterIntersticeParserRuleCall_2_0_0() { return cInterIntersticeParserRuleCall_2_0_0; }
		
		//class += (Classification)+
		public Assignment getClassAssignment_2_1() { return cClassAssignment_2_1; }
		
		//(Classification)
		public RuleCall getClassClassificationParserRuleCall_2_1_0() { return cClassClassificationParserRuleCall_2_1_0; }
		
		//output = ('output')
		public Assignment getOutputAssignment_3() { return cOutputAssignment_3; }
		
		//('output')
		public Keyword getOutputOutputKeyword_3_0() { return cOutputOutputKeyword_3_0; }
	}
	public class DropoutElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Dropout");
		private final Keyword cDropoutKeyword = (Keyword)rule.eContents().get(1);
		
		//// litteraux
		//Dropout: 'dropout';
		@Override public ParserRule getRule() { return rule; }
		
		//'dropout'
		public Keyword getDropoutKeyword() { return cDropoutKeyword; }
	}
	public class PoolingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Pooling");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAvg_poolingKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMax_poolingKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Pooling: 'avg_pooling' | 'max_pooling';
		@Override public ParserRule getRule() { return rule; }
		
		//'avg_pooling' | 'max_pooling'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'avg_pooling'
		public Keyword getAvg_poolingKeyword_0() { return cAvg_poolingKeyword_0; }
		
		//'max_pooling'
		public Keyword getMax_poolingKeyword_1() { return cMax_poolingKeyword_1; }
	}
	public class ConvolutionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Convolution");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cBnconvAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Keyword cBnconvBnconvKeyword_0_0 = (Keyword)cBnconvAssignment_0.eContents().get(0);
		private final Assignment cConvbnAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cConvbnConvbnKeyword_1_0 = (Keyword)cConvbnAssignment_1.eContents().get(0);
		private final Assignment cConvAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final Keyword cConvConvKeyword_2_0 = (Keyword)cConvAssignment_2.eContents().get(0);
		private final Assignment cUpconvAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final Keyword cUpconvUpconvKeyword_3_0 = (Keyword)cUpconvAssignment_3.eContents().get(0);
		
		//Convolution: (bnconv = 'bnconv') | (convbn = 'convbn') | (conv = 'conv') | (upconv = 'upconv') ;
		@Override public ParserRule getRule() { return rule; }
		
		//(bnconv = 'bnconv') | (convbn = 'convbn') | (conv = 'conv') | (upconv = 'upconv')
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(bnconv = 'bnconv')
		public Assignment getBnconvAssignment_0() { return cBnconvAssignment_0; }
		
		//'bnconv'
		public Keyword getBnconvBnconvKeyword_0_0() { return cBnconvBnconvKeyword_0_0; }
		
		//(convbn = 'convbn')
		public Assignment getConvbnAssignment_1() { return cConvbnAssignment_1; }
		
		//'convbn'
		public Keyword getConvbnConvbnKeyword_1_0() { return cConvbnConvbnKeyword_1_0; }
		
		//(conv = 'conv')
		public Assignment getConvAssignment_2() { return cConvAssignment_2; }
		
		//'conv'
		public Keyword getConvConvKeyword_2_0() { return cConvConvKeyword_2_0; }
		
		//(upconv = 'upconv')
		public Assignment getUpconvAssignment_3() { return cUpconvAssignment_3; }
		
		//'upconv'
		public Keyword getUpconvUpconvKeyword_3_0() { return cUpconvUpconvKeyword_3_0; }
	}
	public class GlobalPoolingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.GlobalPooling");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cGlobal_avg_poolingKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cGlobal_max_poolingKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//GlobalPooling: ('global_avg_pooling') | ("global_max_pooling");
		@Override public ParserRule getRule() { return rule; }
		
		//('global_avg_pooling') | ("global_max_pooling")
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//('global_avg_pooling')
		public Keyword getGlobal_avg_poolingKeyword_0() { return cGlobal_avg_poolingKeyword_0; }
		
		//("global_max_pooling")
		public Keyword getGlobal_max_poolingKeyword_1() { return cGlobal_max_poolingKeyword_1; }
	}
	public class FlattenOrGlobalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.FlattenOrGlobal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFlatAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Keyword cFlatFlattenKeyword_0_0 = (Keyword)cFlatAssignment_0.eContents().get(0);
		private final Assignment cGpAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cGpGlobalPoolingParserRuleCall_1_0 = (RuleCall)cGpAssignment_1.eContents().get(0);
		
		//FlattenOrGlobal: (flat='flatten') | (gp = GlobalPooling);
		@Override public ParserRule getRule() { return rule; }
		
		//(flat='flatten') | (gp = GlobalPooling)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(flat='flatten')
		public Assignment getFlatAssignment_0() { return cFlatAssignment_0; }
		
		//'flatten'
		public Keyword getFlatFlattenKeyword_0_0() { return cFlatFlattenKeyword_0_0; }
		
		//(gp = GlobalPooling)
		public Assignment getGpAssignment_1() { return cGpAssignment_1; }
		
		//GlobalPooling
		public RuleCall getGpGlobalPoolingParserRuleCall_1_0() { return cGpGlobalPoolingParserRuleCall_1_0; }
	}
	public class IntersticeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Interstice");
		private final Assignment cFgAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cFgFlattenOrGlobalParserRuleCall_0 = (RuleCall)cFgAssignment.eContents().get(0);
		
		//Interstice: fg = (FlattenOrGlobal);
		@Override public ParserRule getRule() { return rule; }
		
		//fg = (FlattenOrGlobal)
		public Assignment getFgAssignment() { return cFgAssignment; }
		
		//(FlattenOrGlobal)
		public RuleCall getFgFlattenOrGlobalParserRuleCall_0() { return cFgFlattenOrGlobalParserRuleCall_0; }
	}
	public class ClassificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Classification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDropAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDropDropoutParserRuleCall_0_0 = (RuleCall)cDropAssignment_0.eContents().get(0);
		private final Assignment cDAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cDDenseKeyword_1_0 = (Keyword)cDAssignment_1.eContents().get(0);
		
		//Classification: drop =(Dropout)? d=('dense') ;
		@Override public ParserRule getRule() { return rule; }
		
		//drop =(Dropout)? d=('dense')
		public Group getGroup() { return cGroup; }
		
		//drop =(Dropout)?
		public Assignment getDropAssignment_0() { return cDropAssignment_0; }
		
		//(Dropout)
		public RuleCall getDropDropoutParserRuleCall_0_0() { return cDropDropoutParserRuleCall_0_0; }
		
		//d=('dense')
		public Assignment getDAssignment_1() { return cDAssignment_1; }
		
		//('dense')
		public Keyword getDDenseKeyword_1_0() { return cDDenseKeyword_1_0; }
	}
	public class ConvDropElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.ConvDrop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConvAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConvConvolutionParserRuleCall_0_0 = (RuleCall)cConvAssignment_0.eContents().get(0);
		private final Assignment cDropAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDropDropoutParserRuleCall_1_0 = (RuleCall)cDropAssignment_1.eContents().get(0);
		
		//ConvDrop: conv = Convolution (drop = Dropout)?;
		@Override public ParserRule getRule() { return rule; }
		
		//conv = Convolution (drop = Dropout)?
		public Group getGroup() { return cGroup; }
		
		//conv = Convolution
		public Assignment getConvAssignment_0() { return cConvAssignment_0; }
		
		//Convolution
		public RuleCall getConvConvolutionParserRuleCall_0_0() { return cConvConvolutionParserRuleCall_0_0; }
		
		//(drop = Dropout)?
		public Assignment getDropAssignment_1() { return cDropAssignment_1; }
		
		//Dropout
		public RuleCall getDropDropoutParserRuleCall_1_0() { return cDropDropoutParserRuleCall_1_0; }
	}
	public class MergeConvElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.MergeConv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMergeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cMergeMergeParserRuleCall_0_0 = (RuleCall)cMergeAssignment_0.eContents().get(0);
		private final Assignment cConvdropAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConvdropConvDropParserRuleCall_1_0 = (RuleCall)cConvdropAssignment_1.eContents().get(0);
		
		//// Body merge
		//MergeConv:merge=Merge convdrop += (ConvDrop)*;
		@Override public ParserRule getRule() { return rule; }
		
		//merge=Merge convdrop += (ConvDrop)*
		public Group getGroup() { return cGroup; }
		
		//merge=Merge
		public Assignment getMergeAssignment_0() { return cMergeAssignment_0; }
		
		//Merge
		public RuleCall getMergeMergeParserRuleCall_0_0() { return cMergeMergeParserRuleCall_0_0; }
		
		//convdrop += (ConvDrop)*
		public Assignment getConvdropAssignment_1() { return cConvdropAssignment_1; }
		
		//(ConvDrop)
		public RuleCall getConvdropConvDropParserRuleCall_1_0() { return cConvdropConvDropParserRuleCall_1_0; }
	}
	public class ConvOrMergeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.ConvOrMerge");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cConvdropAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cConvdropConvDropParserRuleCall_0_0 = (RuleCall)cConvdropAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cConvdropAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cConvdropConvDropParserRuleCall_1_0_0 = (RuleCall)cConvdropAssignment_1_0.eContents().get(0);
		private final Assignment cMergeConvAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cMergeConvMergeConvParserRuleCall_1_1_0 = (RuleCall)cMergeConvAssignment_1_1.eContents().get(0);
		
		//ConvOrMerge:convdrop += (ConvDrop)+ | convdrop += (ConvDrop)* mergeConv += MergeConv+;
		@Override public ParserRule getRule() { return rule; }
		
		//convdrop += (ConvDrop)+ | convdrop += (ConvDrop)* mergeConv += MergeConv+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//convdrop += (ConvDrop)+
		public Assignment getConvdropAssignment_0() { return cConvdropAssignment_0; }
		
		//(ConvDrop)
		public RuleCall getConvdropConvDropParserRuleCall_0_0() { return cConvdropConvDropParserRuleCall_0_0; }
		
		//convdrop += (ConvDrop)* mergeConv += MergeConv+
		public Group getGroup_1() { return cGroup_1; }
		
		//convdrop += (ConvDrop)*
		public Assignment getConvdropAssignment_1_0() { return cConvdropAssignment_1_0; }
		
		//(ConvDrop)
		public RuleCall getConvdropConvDropParserRuleCall_1_0_0() { return cConvdropConvDropParserRuleCall_1_0_0; }
		
		//mergeConv += MergeConv+
		public Assignment getMergeConvAssignment_1_1() { return cMergeConvAssignment_1_1; }
		
		//MergeConv
		public RuleCall getMergeConvMergeConvParserRuleCall_1_1_0() { return cMergeConvMergeConvParserRuleCall_1_1_0; }
	}
	public class LeftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Left");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPPoolingParserRuleCall_0_0 = (RuleCall)cPAssignment_0.eContents().get(0);
		private final Assignment cComAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cComConvOrMergeParserRuleCall_1_0 = (RuleCall)cComAssignment_1.eContents().get(0);
		private final Assignment cPoolAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPoolPoolingParserRuleCall_2_0 = (RuleCall)cPoolAssignment_2.eContents().get(0);
		
		//Left: (p=Pooling)? com=ConvOrMerge (pool=Pooling)?;
		@Override public ParserRule getRule() { return rule; }
		
		//(p=Pooling)? com=ConvOrMerge (pool=Pooling)?
		public Group getGroup() { return cGroup; }
		
		//(p=Pooling)?
		public Assignment getPAssignment_0() { return cPAssignment_0; }
		
		//Pooling
		public RuleCall getPPoolingParserRuleCall_0_0() { return cPPoolingParserRuleCall_0_0; }
		
		//com=ConvOrMerge
		public Assignment getComAssignment_1() { return cComAssignment_1; }
		
		//ConvOrMerge
		public RuleCall getComConvOrMergeParserRuleCall_1_0() { return cComConvOrMergeParserRuleCall_1_0; }
		
		//(pool=Pooling)?
		public Assignment getPoolAssignment_2() { return cPoolAssignment_2; }
		
		//Pooling
		public RuleCall getPoolPoolingParserRuleCall_2_0() { return cPoolPoolingParserRuleCall_2_0; }
	}
	public class RightElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Right");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cConvAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cConvConvolutionParserRuleCall_0_0 = (RuleCall)cConvAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cRightAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cEmptyAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cEmptyEmptyKeyword_1_1_0 = (Keyword)cEmptyAssignment_1_1.eContents().get(0);
		
		//Right: conv += Convolution+ | {Right} empty = 'Empty';
		@Override public ParserRule getRule() { return rule; }
		
		//conv += Convolution+ | {Right} empty = 'Empty'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//conv += Convolution+
		public Assignment getConvAssignment_0() { return cConvAssignment_0; }
		
		//Convolution
		public RuleCall getConvConvolutionParserRuleCall_0_0() { return cConvConvolutionParserRuleCall_0_0; }
		
		//{Right} empty = 'Empty'
		public Group getGroup_1() { return cGroup_1; }
		
		//{Right}
		public Action getRightAction_1_0() { return cRightAction_1_0; }
		
		//empty = 'Empty'
		public Assignment getEmptyAssignment_1_1() { return cEmptyAssignment_1_1; }
		
		//'Empty'
		public Keyword getEmptyEmptyKeyword_1_1_0() { return cEmptyEmptyKeyword_1_1_0; }
	}
	public class MergeBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.MergeBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftLeftParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cVirgAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cVirgCommaKeyword_2_0 = (Keyword)cVirgAssignment_2.eContents().get(0);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightRightParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//MergeBody:'(' left = Left virg=',' right = Right ')' ;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' left = Left virg=',' right = Right ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//left = Left
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Left
		public RuleCall getLeftLeftParserRuleCall_1_0() { return cLeftLeftParserRuleCall_1_0; }
		
		//virg=','
		public Assignment getVirgAssignment_2() { return cVirgAssignment_2; }
		
		//','
		public Keyword getVirgCommaKeyword_2_0() { return cVirgCommaKeyword_2_0; }
		
		//right = Right
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//Right
		public RuleCall getRightRightParserRuleCall_3_0() { return cRightRightParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class MergeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Merge");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDbAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cDbLeftSquareBracketKeyword_0_0 = (Keyword)cDbAssignment_0.eContents().get(0);
		private final Assignment cMergeBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMergeBodyMergeBodyParserRuleCall_1_0 = (RuleCall)cMergeBodyAssignment_1.eContents().get(0);
		private final Assignment cFmAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cFmRightSquareBracketKeyword_2_0 = (Keyword)cFmAssignment_2.eContents().get(0);
		
		//// Merge
		//Merge:db = '[' (mergeBody+=MergeBody)+  fm = ']' ;
		@Override public ParserRule getRule() { return rule; }
		
		//db = '[' (mergeBody+=MergeBody)+  fm = ']'
		public Group getGroup() { return cGroup; }
		
		//db = '['
		public Assignment getDbAssignment_0() { return cDbAssignment_0; }
		
		//'['
		public Keyword getDbLeftSquareBracketKeyword_0_0() { return cDbLeftSquareBracketKeyword_0_0; }
		
		//(mergeBody+=MergeBody)+
		public Assignment getMergeBodyAssignment_1() { return cMergeBodyAssignment_1; }
		
		//MergeBody
		public RuleCall getMergeBodyMergeBodyParserRuleCall_1_0() { return cMergeBodyMergeBodyParserRuleCall_1_0; }
		
		//fm = ']'
		public Assignment getFmAssignment_2() { return cFmAssignment_2; }
		
		//']'
		public Keyword getFmRightSquareBracketKeyword_2_0() { return cFmRightSquareBracketKeyword_2_0; }
	}
	public class FeatureExtractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.FeatureExtraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cConvAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cConvConvolutionParserRuleCall_0_0_0 = (RuleCall)cConvAssignment_0_0.eContents().get(0);
		private final Assignment cMergeAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cMergeMergeParserRuleCall_0_1_0 = (RuleCall)cMergeAssignment_0_1.eContents().get(0);
		private final Assignment cDropAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDropDropoutParserRuleCall_1_0 = (RuleCall)cDropAssignment_1.eContents().get(0);
		private final Assignment cPoolAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPoolPoolingParserRuleCall_2_0 = (RuleCall)cPoolAssignment_2.eContents().get(0);
		
		////Feature extraction
		//FeatureExtraction:     (conv = Convolution | merge = (Merge)) drop = (Dropout)? pool= (Pooling)?;
		@Override public ParserRule getRule() { return rule; }
		
		//(conv = Convolution | merge = (Merge)) drop = (Dropout)? pool= (Pooling)?
		public Group getGroup() { return cGroup; }
		
		//(conv = Convolution | merge = (Merge))
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//conv = Convolution
		public Assignment getConvAssignment_0_0() { return cConvAssignment_0_0; }
		
		//Convolution
		public RuleCall getConvConvolutionParserRuleCall_0_0_0() { return cConvConvolutionParserRuleCall_0_0_0; }
		
		//merge = (Merge)
		public Assignment getMergeAssignment_0_1() { return cMergeAssignment_0_1; }
		
		//(Merge)
		public RuleCall getMergeMergeParserRuleCall_0_1_0() { return cMergeMergeParserRuleCall_0_1_0; }
		
		//drop = (Dropout)?
		public Assignment getDropAssignment_1() { return cDropAssignment_1; }
		
		//(Dropout)
		public RuleCall getDropDropoutParserRuleCall_1_0() { return cDropDropoutParserRuleCall_1_0; }
		
		//pool= (Pooling)?
		public Assignment getPoolAssignment_2() { return cPoolAssignment_2; }
		
		//(Pooling)
		public RuleCall getPoolPoolingParserRuleCall_2_0() { return cPoolPoolingParserRuleCall_2_0; }
	}
	
	
	private final SMLElements pSML;
	private final ArchitectureElements pArchitecture;
	private final DropoutElements pDropout;
	private final PoolingElements pPooling;
	private final ConvolutionElements pConvolution;
	private final GlobalPoolingElements pGlobalPooling;
	private final FlattenOrGlobalElements pFlattenOrGlobal;
	private final IntersticeElements pInterstice;
	private final ClassificationElements pClassification;
	private final ConvDropElements pConvDrop;
	private final MergeConvElements pMergeConv;
	private final ConvOrMergeElements pConvOrMerge;
	private final LeftElements pLeft;
	private final RightElements pRight;
	private final MergeBodyElements pMergeBody;
	private final MergeElements pMerge;
	private final FeatureExtractionElements pFeatureExtraction;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SMLGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pSML = new SMLElements();
		this.pArchitecture = new ArchitectureElements();
		this.pDropout = new DropoutElements();
		this.pPooling = new PoolingElements();
		this.pConvolution = new ConvolutionElements();
		this.pGlobalPooling = new GlobalPoolingElements();
		this.pFlattenOrGlobal = new FlattenOrGlobalElements();
		this.pInterstice = new IntersticeElements();
		this.pClassification = new ClassificationElements();
		this.pConvDrop = new ConvDropElements();
		this.pMergeConv = new MergeConvElements();
		this.pConvOrMerge = new ConvOrMergeElements();
		this.pLeft = new LeftElements();
		this.pRight = new RightElements();
		this.pMergeBody = new MergeBodyElements();
		this.pMerge = new MergeElements();
		this.pFeatureExtraction = new FeatureExtractionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("xtext.SML".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//SML : sml = (Architecture);
	public SMLElements getSMLAccess() {
		return pSML;
	}
	
	public ParserRule getSMLRule() {
		return getSMLAccess().getRule();
	}
	
	//Architecture : input = ('input') fe += (FeatureExtraction)+ (inter = (Interstice) class += (Classification)+)? output = ('output');
	public ArchitectureElements getArchitectureAccess() {
		return pArchitecture;
	}
	
	public ParserRule getArchitectureRule() {
		return getArchitectureAccess().getRule();
	}
	
	//// litteraux
	//Dropout: 'dropout';
	public DropoutElements getDropoutAccess() {
		return pDropout;
	}
	
	public ParserRule getDropoutRule() {
		return getDropoutAccess().getRule();
	}
	
	//Pooling: 'avg_pooling' | 'max_pooling';
	public PoolingElements getPoolingAccess() {
		return pPooling;
	}
	
	public ParserRule getPoolingRule() {
		return getPoolingAccess().getRule();
	}
	
	//Convolution: (bnconv = 'bnconv') | (convbn = 'convbn') | (conv = 'conv') | (upconv = 'upconv') ;
	public ConvolutionElements getConvolutionAccess() {
		return pConvolution;
	}
	
	public ParserRule getConvolutionRule() {
		return getConvolutionAccess().getRule();
	}
	
	//GlobalPooling: ('global_avg_pooling') | ("global_max_pooling");
	public GlobalPoolingElements getGlobalPoolingAccess() {
		return pGlobalPooling;
	}
	
	public ParserRule getGlobalPoolingRule() {
		return getGlobalPoolingAccess().getRule();
	}
	
	//FlattenOrGlobal: (flat='flatten') | (gp = GlobalPooling);
	public FlattenOrGlobalElements getFlattenOrGlobalAccess() {
		return pFlattenOrGlobal;
	}
	
	public ParserRule getFlattenOrGlobalRule() {
		return getFlattenOrGlobalAccess().getRule();
	}
	
	//Interstice: fg = (FlattenOrGlobal);
	public IntersticeElements getIntersticeAccess() {
		return pInterstice;
	}
	
	public ParserRule getIntersticeRule() {
		return getIntersticeAccess().getRule();
	}
	
	//Classification: drop =(Dropout)? d=('dense') ;
	public ClassificationElements getClassificationAccess() {
		return pClassification;
	}
	
	public ParserRule getClassificationRule() {
		return getClassificationAccess().getRule();
	}
	
	//ConvDrop: conv = Convolution (drop = Dropout)?;
	public ConvDropElements getConvDropAccess() {
		return pConvDrop;
	}
	
	public ParserRule getConvDropRule() {
		return getConvDropAccess().getRule();
	}
	
	//// Body merge
	//MergeConv:merge=Merge convdrop += (ConvDrop)*;
	public MergeConvElements getMergeConvAccess() {
		return pMergeConv;
	}
	
	public ParserRule getMergeConvRule() {
		return getMergeConvAccess().getRule();
	}
	
	//ConvOrMerge:convdrop += (ConvDrop)+ | convdrop += (ConvDrop)* mergeConv += MergeConv+;
	public ConvOrMergeElements getConvOrMergeAccess() {
		return pConvOrMerge;
	}
	
	public ParserRule getConvOrMergeRule() {
		return getConvOrMergeAccess().getRule();
	}
	
	//Left: (p=Pooling)? com=ConvOrMerge (pool=Pooling)?;
	public LeftElements getLeftAccess() {
		return pLeft;
	}
	
	public ParserRule getLeftRule() {
		return getLeftAccess().getRule();
	}
	
	//Right: conv += Convolution+ | {Right} empty = 'Empty';
	public RightElements getRightAccess() {
		return pRight;
	}
	
	public ParserRule getRightRule() {
		return getRightAccess().getRule();
	}
	
	//MergeBody:'(' left = Left virg=',' right = Right ')' ;
	public MergeBodyElements getMergeBodyAccess() {
		return pMergeBody;
	}
	
	public ParserRule getMergeBodyRule() {
		return getMergeBodyAccess().getRule();
	}
	
	//// Merge
	//Merge:db = '[' (mergeBody+=MergeBody)+  fm = ']' ;
	public MergeElements getMergeAccess() {
		return pMerge;
	}
	
	public ParserRule getMergeRule() {
		return getMergeAccess().getRule();
	}
	
	////Feature extraction
	//FeatureExtraction:     (conv = Convolution | merge = (Merge)) drop = (Dropout)? pool= (Pooling)?;
	public FeatureExtractionElements getFeatureExtractionAccess() {
		return pFeatureExtraction;
	}
	
	public ParserRule getFeatureExtractionRule() {
		return getFeatureExtractionAccess().getRule();
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
