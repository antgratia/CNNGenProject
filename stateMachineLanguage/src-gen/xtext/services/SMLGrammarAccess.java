/*
 * generated by Xtext 2.25.0
 */
package xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SMLGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class SMLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.SML");
		private final Assignment cSmlAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cSmlArchitectureParserRuleCall_0 = (RuleCall)cSmlAssignment.eContents().get(0);
		
		//SML : sml = (Architecture);
		@Override public ParserRule getRule() { return rule; }
		
		//sml = (Architecture)
		public Assignment getSmlAssignment() { return cSmlAssignment; }
		
		//(Architecture)
		public RuleCall getSmlArchitectureParserRuleCall_0() { return cSmlArchitectureParserRuleCall_0; }
	}
	public class ArchitectureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Architecture");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInputAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cInputInputKeyword_0_0 = (Keyword)cInputAssignment_0.eContents().get(0);
		private final Assignment cFeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFeFeatureExtractionParserRuleCall_1_0 = (RuleCall)cFeAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cInterAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cInterIntersticeParserRuleCall_2_0_0 = (RuleCall)cInterAssignment_2_0.eContents().get(0);
		private final Assignment cClassAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cClassClassificationParserRuleCall_2_1_0 = (RuleCall)cClassAssignment_2_1.eContents().get(0);
		private final Assignment cOutputAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cOutputOutputKeyword_3_0 = (Keyword)cOutputAssignment_3.eContents().get(0);
		
		//Architecture : input = ('input') fe += (FeatureExtraction)+ (inter = (Interstice) class += (Classification)*)? output = ('output');
		@Override public ParserRule getRule() { return rule; }
		
		//input = ('input') fe += (FeatureExtraction)+ (inter = (Interstice) class += (Classification)*)? output = ('output')
		public Group getGroup() { return cGroup; }
		
		//input = ('input')
		public Assignment getInputAssignment_0() { return cInputAssignment_0; }
		
		//('input')
		public Keyword getInputInputKeyword_0_0() { return cInputInputKeyword_0_0; }
		
		//fe += (FeatureExtraction)+
		public Assignment getFeAssignment_1() { return cFeAssignment_1; }
		
		//(FeatureExtraction)
		public RuleCall getFeFeatureExtractionParserRuleCall_1_0() { return cFeFeatureExtractionParserRuleCall_1_0; }
		
		//(inter = (Interstice) class += (Classification)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//inter = (Interstice)
		public Assignment getInterAssignment_2_0() { return cInterAssignment_2_0; }
		
		//(Interstice)
		public RuleCall getInterIntersticeParserRuleCall_2_0_0() { return cInterIntersticeParserRuleCall_2_0_0; }
		
		//class += (Classification)*
		public Assignment getClassAssignment_2_1() { return cClassAssignment_2_1; }
		
		//(Classification)
		public RuleCall getClassClassificationParserRuleCall_2_1_0() { return cClassClassificationParserRuleCall_2_1_0; }
		
		//output = ('output')
		public Assignment getOutputAssignment_3() { return cOutputAssignment_3; }
		
		//('output')
		public Keyword getOutputOutputKeyword_3_0() { return cOutputOutputKeyword_3_0; }
	}
	public class DropoutElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Dropout");
		private final Keyword cDropoutKeyword = (Keyword)rule.eContents().get(1);
		
		//// Unit
		//Dropout: 'dropout';
		@Override public ParserRule getRule() { return rule; }
		
		//'dropout'
		public Keyword getDropoutKeyword() { return cDropoutKeyword; }
	}
	public class PoolingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Pooling");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAvg_poolingKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMax_poolingKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Pooling: 'avg_pooling' | 'max_pooling';
		@Override public ParserRule getRule() { return rule; }
		
		//'avg_pooling' | 'max_pooling'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'avg_pooling'
		public Keyword getAvg_poolingKeyword_0() { return cAvg_poolingKeyword_0; }
		
		//'max_pooling'
		public Keyword getMax_poolingKeyword_1() { return cMax_poolingKeyword_1; }
	}
	public class DebutMergeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.DebutMerge");
		private final Keyword cLeftSquareBracketKeyword = (Keyword)rule.eContents().get(1);
		
		//DebutMerge: '[';
		@Override public ParserRule getRule() { return rule; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword() { return cLeftSquareBracketKeyword; }
	}
	public class FinMergeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.FinMerge");
		private final Keyword cRightSquareBracketKeyword = (Keyword)rule.eContents().get(1);
		
		//FinMerge: ']';
		@Override public ParserRule getRule() { return rule; }
		
		//']'
		public Keyword getRightSquareBracketKeyword() { return cRightSquareBracketKeyword; }
	}
	public class BnConvElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.BnConv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cBnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cConvKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//BnConv:('(') ('bn') ('conv') (')');
		@Override public ParserRule getRule() { return rule; }
		
		//('(') ('bn') ('conv') (')')
		public Group getGroup() { return cGroup; }
		
		//('(')
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//('bn')
		public Keyword getBnKeyword_1() { return cBnKeyword_1; }
		
		//('conv')
		public Keyword getConvKeyword_2() { return cConvKeyword_2; }
		
		//(')')
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ConvBnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.ConvBn");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cConvKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cBnKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ConvBn:('(') ('conv') ('bn') (')');
		@Override public ParserRule getRule() { return rule; }
		
		//('(') ('conv') ('bn') (')')
		public Group getGroup() { return cGroup; }
		
		//('(')
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//('conv')
		public Keyword getConvKeyword_1() { return cConvKeyword_1; }
		
		//('bn')
		public Keyword getBnKeyword_2() { return cBnKeyword_2; }
		
		//(')')
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ConvolutionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Convolution");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cBnconvAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cBnconvBnConvParserRuleCall_0_0 = (RuleCall)cBnconvAssignment_0.eContents().get(0);
		private final Assignment cConvbnAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cConvbnConvBnParserRuleCall_1_0 = (RuleCall)cConvbnAssignment_1.eContents().get(0);
		private final Assignment cConvAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final Keyword cConvConvKeyword_2_0 = (Keyword)cConvAssignment_2.eContents().get(0);
		private final Assignment cUpconvAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final Keyword cUpconvUpconvKeyword_3_0 = (Keyword)cUpconvAssignment_3.eContents().get(0);
		
		//Convolution: bnconv = (BnConv)| (convbn = ConvBn ) | (conv = 'conv') | (upconv = 'upconv') ;
		@Override public ParserRule getRule() { return rule; }
		
		//bnconv = (BnConv)| (convbn = ConvBn ) | (conv = 'conv') | (upconv = 'upconv')
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//bnconv = (BnConv)
		public Assignment getBnconvAssignment_0() { return cBnconvAssignment_0; }
		
		//(BnConv)
		public RuleCall getBnconvBnConvParserRuleCall_0_0() { return cBnconvBnConvParserRuleCall_0_0; }
		
		//(convbn = ConvBn )
		public Assignment getConvbnAssignment_1() { return cConvbnAssignment_1; }
		
		//ConvBn
		public RuleCall getConvbnConvBnParserRuleCall_1_0() { return cConvbnConvBnParserRuleCall_1_0; }
		
		//(conv = 'conv')
		public Assignment getConvAssignment_2() { return cConvAssignment_2; }
		
		//'conv'
		public Keyword getConvConvKeyword_2_0() { return cConvConvKeyword_2_0; }
		
		//(upconv = 'upconv')
		public Assignment getUpconvAssignment_3() { return cUpconvAssignment_3; }
		
		//'upconv'
		public Keyword getUpconvUpconvKeyword_3_0() { return cUpconvUpconvKeyword_3_0; }
	}
	public class GlobalPoolingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.GlobalPooling");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cGlobal_avg_poolingKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cGlobal_max_poolingKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//GlobalPooling: ('global_avg_pooling') | ("global_max_pooling");
		@Override public ParserRule getRule() { return rule; }
		
		//('global_avg_pooling') | ("global_max_pooling")
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//('global_avg_pooling')
		public Keyword getGlobal_avg_poolingKeyword_0() { return cGlobal_avg_poolingKeyword_0; }
		
		//("global_max_pooling")
		public Keyword getGlobal_max_poolingKeyword_1() { return cGlobal_max_poolingKeyword_1; }
	}
	public class FlattenOrGlobalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.FlattenOrGlobal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFlatAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Keyword cFlatFlattenKeyword_0_0 = (Keyword)cFlatAssignment_0.eContents().get(0);
		private final Assignment cGpAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cGpGlobalPoolingParserRuleCall_1_0 = (RuleCall)cGpAssignment_1.eContents().get(0);
		
		//FlattenOrGlobal: (flat='flatten') | (gp = GlobalPooling);
		@Override public ParserRule getRule() { return rule; }
		
		//(flat='flatten') | (gp = GlobalPooling)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(flat='flatten')
		public Assignment getFlatAssignment_0() { return cFlatAssignment_0; }
		
		//'flatten'
		public Keyword getFlatFlattenKeyword_0_0() { return cFlatFlattenKeyword_0_0; }
		
		//(gp = GlobalPooling)
		public Assignment getGpAssignment_1() { return cGpAssignment_1; }
		
		//GlobalPooling
		public RuleCall getGpGlobalPoolingParserRuleCall_1_0() { return cGpGlobalPoolingParserRuleCall_1_0; }
	}
	public class IntersticeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Interstice");
		private final Assignment cFgAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cFgFlattenOrGlobalParserRuleCall_0 = (RuleCall)cFgAssignment.eContents().get(0);
		
		//Interstice: fg = (FlattenOrGlobal);
		@Override public ParserRule getRule() { return rule; }
		
		//fg = (FlattenOrGlobal)
		public Assignment getFgAssignment() { return cFgAssignment; }
		
		//(FlattenOrGlobal)
		public RuleCall getFgFlattenOrGlobalParserRuleCall_0() { return cFgFlattenOrGlobalParserRuleCall_0; }
	}
	public class ClassificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Classification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDropAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDropDropoutParserRuleCall_0_0 = (RuleCall)cDropAssignment_0.eContents().get(0);
		private final Assignment cDAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cDDenseKeyword_1_0 = (Keyword)cDAssignment_1.eContents().get(0);
		
		//Classification: drop =(Dropout)? d=('dense') ;
		@Override public ParserRule getRule() { return rule; }
		
		//drop =(Dropout)? d=('dense')
		public Group getGroup() { return cGroup; }
		
		//drop =(Dropout)?
		public Assignment getDropAssignment_0() { return cDropAssignment_0; }
		
		//(Dropout)
		public RuleCall getDropDropoutParserRuleCall_0_0() { return cDropDropoutParserRuleCall_0_0; }
		
		//d=('dense')
		public Assignment getDAssignment_1() { return cDAssignment_1; }
		
		//('dense')
		public Keyword getDDenseKeyword_1_0() { return cDDenseKeyword_1_0; }
	}
	public class ConvDropElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.ConvDrop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConvAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConvConvolutionParserRuleCall_0_0 = (RuleCall)cConvAssignment_0.eContents().get(0);
		private final Assignment cDropAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDropDropoutParserRuleCall_1_0 = (RuleCall)cDropAssignment_1.eContents().get(0);
		
		//ConvDrop: conv = Convolution (drop = Dropout)?;
		@Override public ParserRule getRule() { return rule; }
		
		//conv = Convolution (drop = Dropout)?
		public Group getGroup() { return cGroup; }
		
		//conv = Convolution
		public Assignment getConvAssignment_0() { return cConvAssignment_0; }
		
		//Convolution
		public RuleCall getConvConvolutionParserRuleCall_0_0() { return cConvConvolutionParserRuleCall_0_0; }
		
		//(drop = Dropout)?
		public Assignment getDropAssignment_1() { return cDropAssignment_1; }
		
		//Dropout
		public RuleCall getDropDropoutParserRuleCall_1_0() { return cDropDropoutParserRuleCall_1_0; }
	}
	public class LeftRecuElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.LeftRecu");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPPoolingParserRuleCall_0_0 = (RuleCall)cPAssignment_0.eContents().get(0);
		private final Assignment cConvdropbeginAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConvdropbeginConvDropParserRuleCall_1_0 = (RuleCall)cConvdropbeginAssignment_1.eContents().get(0);
		private final Assignment cMergeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMergeMergeParserRuleCall_2_0 = (RuleCall)cMergeAssignment_2.eContents().get(0);
		private final Assignment cConvdropendAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConvdropendConvDropParserRuleCall_3_0 = (RuleCall)cConvdropendAssignment_3.eContents().get(0);
		private final Assignment cPoolAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPoolPoolingParserRuleCall_4_0 = (RuleCall)cPoolAssignment_4.eContents().get(0);
		
		//// Merge Recursive
		//LeftRecu: (p=Pooling)? convdropbegin += (ConvDrop)* (merge = Merge) convdropend += (ConvDrop)* (pool=Pooling)?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(p=Pooling)? convdropbegin += (ConvDrop)* (merge = Merge) convdropend += (ConvDrop)* (pool=Pooling)?
		public Group getGroup() { return cGroup; }
		
		//(p=Pooling)?
		public Assignment getPAssignment_0() { return cPAssignment_0; }
		
		//Pooling
		public RuleCall getPPoolingParserRuleCall_0_0() { return cPPoolingParserRuleCall_0_0; }
		
		//convdropbegin += (ConvDrop)*
		public Assignment getConvdropbeginAssignment_1() { return cConvdropbeginAssignment_1; }
		
		//(ConvDrop)
		public RuleCall getConvdropbeginConvDropParserRuleCall_1_0() { return cConvdropbeginConvDropParserRuleCall_1_0; }
		
		//(merge = Merge)
		public Assignment getMergeAssignment_2() { return cMergeAssignment_2; }
		
		//Merge
		public RuleCall getMergeMergeParserRuleCall_2_0() { return cMergeMergeParserRuleCall_2_0; }
		
		//convdropend += (ConvDrop)*
		public Assignment getConvdropendAssignment_3() { return cConvdropendAssignment_3; }
		
		//(ConvDrop)
		public RuleCall getConvdropendConvDropParserRuleCall_3_0() { return cConvdropendConvDropParserRuleCall_3_0; }
		
		//(pool=Pooling)?
		public Assignment getPoolAssignment_4() { return cPoolAssignment_4; }
		
		//Pooling
		public RuleCall getPoolPoolingParserRuleCall_4_0() { return cPoolPoolingParserRuleCall_4_0; }
	}
	public class MergeRecuElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.MergeRecu");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDbAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDbDebutMergeParserRuleCall_0_0 = (RuleCall)cDbAssignment_0.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftLeftRecuParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Assignment cVirgAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cVirgCommaKeyword_2_0 = (Keyword)cVirgAssignment_2.eContents().get(0);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightRightParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Assignment cFmAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFmFinMergeParserRuleCall_4_0 = (RuleCall)cFmAssignment_4.eContents().get(0);
		
		//MergeRecu:  db = DebutMerge left = LeftRecu virg=','  right = Right  fm = FinMerge ;
		@Override public ParserRule getRule() { return rule; }
		
		//db = DebutMerge left = LeftRecu virg=','  right = Right  fm = FinMerge
		public Group getGroup() { return cGroup; }
		
		//db = DebutMerge
		public Assignment getDbAssignment_0() { return cDbAssignment_0; }
		
		//DebutMerge
		public RuleCall getDbDebutMergeParserRuleCall_0_0() { return cDbDebutMergeParserRuleCall_0_0; }
		
		//left = LeftRecu
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//LeftRecu
		public RuleCall getLeftLeftRecuParserRuleCall_1_0() { return cLeftLeftRecuParserRuleCall_1_0; }
		
		//virg=','
		public Assignment getVirgAssignment_2() { return cVirgAssignment_2; }
		
		//','
		public Keyword getVirgCommaKeyword_2_0() { return cVirgCommaKeyword_2_0; }
		
		//right = Right
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//Right
		public RuleCall getRightRightParserRuleCall_3_0() { return cRightRightParserRuleCall_3_0; }
		
		//fm = FinMerge
		public Assignment getFmAssignment_4() { return cFmAssignment_4; }
		
		//FinMerge
		public RuleCall getFmFinMergeParserRuleCall_4_0() { return cFmFinMergeParserRuleCall_4_0; }
	}
	public class LeftNonRecursiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.LeftNonRecursive");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPPoolingParserRuleCall_0_0 = (RuleCall)cPAssignment_0.eContents().get(0);
		private final Assignment cConvdropAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConvdropConvDropParserRuleCall_1_0 = (RuleCall)cConvdropAssignment_1.eContents().get(0);
		private final Assignment cPoolAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPoolPoolingParserRuleCall_2_0 = (RuleCall)cPoolAssignment_2.eContents().get(0);
		
		//// Merge Non recusive
		//LeftNonRecursive: p = (Pooling)? convdrop += (ConvDrop)+ pool = (Pooling)?;
		@Override public ParserRule getRule() { return rule; }
		
		//p = (Pooling)? convdrop += (ConvDrop)+ pool = (Pooling)?
		public Group getGroup() { return cGroup; }
		
		//p = (Pooling)?
		public Assignment getPAssignment_0() { return cPAssignment_0; }
		
		//(Pooling)
		public RuleCall getPPoolingParserRuleCall_0_0() { return cPPoolingParserRuleCall_0_0; }
		
		//convdrop += (ConvDrop)+
		public Assignment getConvdropAssignment_1() { return cConvdropAssignment_1; }
		
		//(ConvDrop)
		public RuleCall getConvdropConvDropParserRuleCall_1_0() { return cConvdropConvDropParserRuleCall_1_0; }
		
		//pool = (Pooling)?
		public Assignment getPoolAssignment_2() { return cPoolAssignment_2; }
		
		//(Pooling)
		public RuleCall getPoolPoolingParserRuleCall_2_0() { return cPoolPoolingParserRuleCall_2_0; }
	}
	public class RightElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Right");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cConvAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cConvConvolutionParserRuleCall_0_0 = (RuleCall)cConvAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cRightAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cEmptyAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cEmptyEmptyKeyword_1_1_0 = (Keyword)cEmptyAssignment_1_1.eContents().get(0);
		
		//Right: conv += Convolution+ | {Right} empty = 'Empty';
		@Override public ParserRule getRule() { return rule; }
		
		//conv += Convolution+ | {Right} empty = 'Empty'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//conv += Convolution+
		public Assignment getConvAssignment_0() { return cConvAssignment_0; }
		
		//Convolution
		public RuleCall getConvConvolutionParserRuleCall_0_0() { return cConvConvolutionParserRuleCall_0_0; }
		
		//{Right} empty = 'Empty'
		public Group getGroup_1() { return cGroup_1; }
		
		//{Right}
		public Action getRightAction_1_0() { return cRightAction_1_0; }
		
		//empty = 'Empty'
		public Assignment getEmptyAssignment_1_1() { return cEmptyAssignment_1_1; }
		
		//'Empty'
		public Keyword getEmptyEmptyKeyword_1_1_0() { return cEmptyEmptyKeyword_1_1_0; }
	}
	public class MergeNonRecuElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.MergeNonRecu");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDbAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDbDebutMergeParserRuleCall_0_0 = (RuleCall)cDbAssignment_0.eContents().get(0);
		private final Assignment cLeftNonRecAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftNonRecLeftNonRecursiveParserRuleCall_1_0 = (RuleCall)cLeftNonRecAssignment_1.eContents().get(0);
		private final Assignment cVirgAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cVirgCommaKeyword_2_0 = (Keyword)cVirgAssignment_2.eContents().get(0);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightRightParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Assignment cFmAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFmFinMergeParserRuleCall_4_0 = (RuleCall)cFmAssignment_4.eContents().get(0);
		
		//MergeNonRecu: db = DebutMerge leftNonRec = LeftNonRecursive virg=','  right = Right fm = FinMerge;
		@Override public ParserRule getRule() { return rule; }
		
		//db = DebutMerge leftNonRec = LeftNonRecursive virg=','  right = Right fm = FinMerge
		public Group getGroup() { return cGroup; }
		
		//db = DebutMerge
		public Assignment getDbAssignment_0() { return cDbAssignment_0; }
		
		//DebutMerge
		public RuleCall getDbDebutMergeParserRuleCall_0_0() { return cDbDebutMergeParserRuleCall_0_0; }
		
		//leftNonRec = LeftNonRecursive
		public Assignment getLeftNonRecAssignment_1() { return cLeftNonRecAssignment_1; }
		
		//LeftNonRecursive
		public RuleCall getLeftNonRecLeftNonRecursiveParserRuleCall_1_0() { return cLeftNonRecLeftNonRecursiveParserRuleCall_1_0; }
		
		//virg=','
		public Assignment getVirgAssignment_2() { return cVirgAssignment_2; }
		
		//','
		public Keyword getVirgCommaKeyword_2_0() { return cVirgCommaKeyword_2_0; }
		
		//right = Right
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//Right
		public RuleCall getRightRightParserRuleCall_3_0() { return cRightRightParserRuleCall_3_0; }
		
		//fm = FinMerge
		public Assignment getFmAssignment_4() { return cFmAssignment_4; }
		
		//FinMerge
		public RuleCall getFmFinMergeParserRuleCall_4_0() { return cFmFinMergeParserRuleCall_4_0; }
	}
	public class MergeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Merge");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cMnrAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cMnrMergeNonRecuParserRuleCall_0_0 = (RuleCall)cMnrAssignment_0.eContents().get(0);
		private final Assignment cMrAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cMrMergeRecuParserRuleCall_1_0 = (RuleCall)cMrAssignment_1.eContents().get(0);
		
		//// Merge
		//Merge: mnr = MergeNonRecu | mr = MergeRecu;
		@Override public ParserRule getRule() { return rule; }
		
		//mnr = MergeNonRecu | mr = MergeRecu
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//mnr = MergeNonRecu
		public Assignment getMnrAssignment_0() { return cMnrAssignment_0; }
		
		//MergeNonRecu
		public RuleCall getMnrMergeNonRecuParserRuleCall_0_0() { return cMnrMergeNonRecuParserRuleCall_0_0; }
		
		//mr = MergeRecu
		public Assignment getMrAssignment_1() { return cMrAssignment_1; }
		
		//MergeRecu
		public RuleCall getMrMergeRecuParserRuleCall_1_0() { return cMrMergeRecuParserRuleCall_1_0; }
	}
	public class HighwayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.Highway");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDbAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDbDebutMergeParserRuleCall_0_0 = (RuleCall)cDbAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cLeftNonRecAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cLeftNonRecLeftNonRecursiveParserRuleCall_1_0_0 = (RuleCall)cLeftNonRecAssignment_1_0.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cConvAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cConvConvolutionParserRuleCall_1_2_0 = (RuleCall)cConvAssignment_1_2.eContents().get(0);
		private final Keyword cCommaKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cFmAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFmFinMergeParserRuleCall_2_0 = (RuleCall)cFmAssignment_2.eContents().get(0);
		
		//Highway: (db += DebutMerge) ((leftNonRec+=LeftNonRecursive) ('|') (conv += Convolution) (','))+ (fm += FinMerge);
		@Override public ParserRule getRule() { return rule; }
		
		//(db += DebutMerge) ((leftNonRec+=LeftNonRecursive) ('|') (conv += Convolution) (','))+ (fm += FinMerge)
		public Group getGroup() { return cGroup; }
		
		//(db += DebutMerge)
		public Assignment getDbAssignment_0() { return cDbAssignment_0; }
		
		//DebutMerge
		public RuleCall getDbDebutMergeParserRuleCall_0_0() { return cDbDebutMergeParserRuleCall_0_0; }
		
		//((leftNonRec+=LeftNonRecursive) ('|') (conv += Convolution) (','))+
		public Group getGroup_1() { return cGroup_1; }
		
		//(leftNonRec+=LeftNonRecursive)
		public Assignment getLeftNonRecAssignment_1_0() { return cLeftNonRecAssignment_1_0; }
		
		//LeftNonRecursive
		public RuleCall getLeftNonRecLeftNonRecursiveParserRuleCall_1_0_0() { return cLeftNonRecLeftNonRecursiveParserRuleCall_1_0_0; }
		
		//('|')
		public Keyword getVerticalLineKeyword_1_1() { return cVerticalLineKeyword_1_1; }
		
		//(conv += Convolution)
		public Assignment getConvAssignment_1_2() { return cConvAssignment_1_2; }
		
		//Convolution
		public RuleCall getConvConvolutionParserRuleCall_1_2_0() { return cConvConvolutionParserRuleCall_1_2_0; }
		
		//(',')
		public Keyword getCommaKeyword_1_3() { return cCommaKeyword_1_3; }
		
		//(fm += FinMerge)
		public Assignment getFmAssignment_2() { return cFmAssignment_2; }
		
		//FinMerge
		public RuleCall getFmFinMergeParserRuleCall_2_0() { return cFmFinMergeParserRuleCall_2_0; }
	}
	public class FeatureExtractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xtext.SML.FeatureExtraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cConvAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cConvConvolutionParserRuleCall_0_0_0 = (RuleCall)cConvAssignment_0_0.eContents().get(0);
		private final Assignment cMergeAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cMergeMergeParserRuleCall_0_1_0 = (RuleCall)cMergeAssignment_0_1.eContents().get(0);
		private final Assignment cHwAssignment_0_2 = (Assignment)cAlternatives_0.eContents().get(2);
		private final RuleCall cHwHighwayParserRuleCall_0_2_0 = (RuleCall)cHwAssignment_0_2.eContents().get(0);
		private final Assignment cDropAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDropDropoutParserRuleCall_1_0 = (RuleCall)cDropAssignment_1.eContents().get(0);
		private final Assignment cPoolAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPoolPoolingParserRuleCall_2_0 = (RuleCall)cPoolAssignment_2.eContents().get(0);
		
		////Feature extraction
		//FeatureExtraction:     (conv = Convolution | merge = (Merge) | hw = (Highway)) drop = (Dropout)? pool= (Pooling)?;
		@Override public ParserRule getRule() { return rule; }
		
		//(conv = Convolution | merge = (Merge) | hw = (Highway)) drop = (Dropout)? pool= (Pooling)?
		public Group getGroup() { return cGroup; }
		
		//(conv = Convolution | merge = (Merge) | hw = (Highway))
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//conv = Convolution
		public Assignment getConvAssignment_0_0() { return cConvAssignment_0_0; }
		
		//Convolution
		public RuleCall getConvConvolutionParserRuleCall_0_0_0() { return cConvConvolutionParserRuleCall_0_0_0; }
		
		//merge = (Merge)
		public Assignment getMergeAssignment_0_1() { return cMergeAssignment_0_1; }
		
		//(Merge)
		public RuleCall getMergeMergeParserRuleCall_0_1_0() { return cMergeMergeParserRuleCall_0_1_0; }
		
		//hw = (Highway)
		public Assignment getHwAssignment_0_2() { return cHwAssignment_0_2; }
		
		//(Highway)
		public RuleCall getHwHighwayParserRuleCall_0_2_0() { return cHwHighwayParserRuleCall_0_2_0; }
		
		//drop = (Dropout)?
		public Assignment getDropAssignment_1() { return cDropAssignment_1; }
		
		//(Dropout)
		public RuleCall getDropDropoutParserRuleCall_1_0() { return cDropDropoutParserRuleCall_1_0; }
		
		//pool= (Pooling)?
		public Assignment getPoolAssignment_2() { return cPoolAssignment_2; }
		
		//(Pooling)
		public RuleCall getPoolPoolingParserRuleCall_2_0() { return cPoolPoolingParserRuleCall_2_0; }
	}
	
	
	private final SMLElements pSML;
	private final ArchitectureElements pArchitecture;
	private final DropoutElements pDropout;
	private final PoolingElements pPooling;
	private final DebutMergeElements pDebutMerge;
	private final FinMergeElements pFinMerge;
	private final BnConvElements pBnConv;
	private final ConvBnElements pConvBn;
	private final ConvolutionElements pConvolution;
	private final GlobalPoolingElements pGlobalPooling;
	private final FlattenOrGlobalElements pFlattenOrGlobal;
	private final IntersticeElements pInterstice;
	private final ClassificationElements pClassification;
	private final ConvDropElements pConvDrop;
	private final LeftRecuElements pLeftRecu;
	private final MergeRecuElements pMergeRecu;
	private final LeftNonRecursiveElements pLeftNonRecursive;
	private final RightElements pRight;
	private final MergeNonRecuElements pMergeNonRecu;
	private final MergeElements pMerge;
	private final HighwayElements pHighway;
	private final FeatureExtractionElements pFeatureExtraction;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SMLGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pSML = new SMLElements();
		this.pArchitecture = new ArchitectureElements();
		this.pDropout = new DropoutElements();
		this.pPooling = new PoolingElements();
		this.pDebutMerge = new DebutMergeElements();
		this.pFinMerge = new FinMergeElements();
		this.pBnConv = new BnConvElements();
		this.pConvBn = new ConvBnElements();
		this.pConvolution = new ConvolutionElements();
		this.pGlobalPooling = new GlobalPoolingElements();
		this.pFlattenOrGlobal = new FlattenOrGlobalElements();
		this.pInterstice = new IntersticeElements();
		this.pClassification = new ClassificationElements();
		this.pConvDrop = new ConvDropElements();
		this.pLeftRecu = new LeftRecuElements();
		this.pMergeRecu = new MergeRecuElements();
		this.pLeftNonRecursive = new LeftNonRecursiveElements();
		this.pRight = new RightElements();
		this.pMergeNonRecu = new MergeNonRecuElements();
		this.pMerge = new MergeElements();
		this.pHighway = new HighwayElements();
		this.pFeatureExtraction = new FeatureExtractionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("xtext.SML".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//SML : sml = (Architecture);
	public SMLElements getSMLAccess() {
		return pSML;
	}
	
	public ParserRule getSMLRule() {
		return getSMLAccess().getRule();
	}
	
	//Architecture : input = ('input') fe += (FeatureExtraction)+ (inter = (Interstice) class += (Classification)*)? output = ('output');
	public ArchitectureElements getArchitectureAccess() {
		return pArchitecture;
	}
	
	public ParserRule getArchitectureRule() {
		return getArchitectureAccess().getRule();
	}
	
	//// Unit
	//Dropout: 'dropout';
	public DropoutElements getDropoutAccess() {
		return pDropout;
	}
	
	public ParserRule getDropoutRule() {
		return getDropoutAccess().getRule();
	}
	
	//Pooling: 'avg_pooling' | 'max_pooling';
	public PoolingElements getPoolingAccess() {
		return pPooling;
	}
	
	public ParserRule getPoolingRule() {
		return getPoolingAccess().getRule();
	}
	
	//DebutMerge: '[';
	public DebutMergeElements getDebutMergeAccess() {
		return pDebutMerge;
	}
	
	public ParserRule getDebutMergeRule() {
		return getDebutMergeAccess().getRule();
	}
	
	//FinMerge: ']';
	public FinMergeElements getFinMergeAccess() {
		return pFinMerge;
	}
	
	public ParserRule getFinMergeRule() {
		return getFinMergeAccess().getRule();
	}
	
	//BnConv:('(') ('bn') ('conv') (')');
	public BnConvElements getBnConvAccess() {
		return pBnConv;
	}
	
	public ParserRule getBnConvRule() {
		return getBnConvAccess().getRule();
	}
	
	//ConvBn:('(') ('conv') ('bn') (')');
	public ConvBnElements getConvBnAccess() {
		return pConvBn;
	}
	
	public ParserRule getConvBnRule() {
		return getConvBnAccess().getRule();
	}
	
	//Convolution: bnconv = (BnConv)| (convbn = ConvBn ) | (conv = 'conv') | (upconv = 'upconv') ;
	public ConvolutionElements getConvolutionAccess() {
		return pConvolution;
	}
	
	public ParserRule getConvolutionRule() {
		return getConvolutionAccess().getRule();
	}
	
	//GlobalPooling: ('global_avg_pooling') | ("global_max_pooling");
	public GlobalPoolingElements getGlobalPoolingAccess() {
		return pGlobalPooling;
	}
	
	public ParserRule getGlobalPoolingRule() {
		return getGlobalPoolingAccess().getRule();
	}
	
	//FlattenOrGlobal: (flat='flatten') | (gp = GlobalPooling);
	public FlattenOrGlobalElements getFlattenOrGlobalAccess() {
		return pFlattenOrGlobal;
	}
	
	public ParserRule getFlattenOrGlobalRule() {
		return getFlattenOrGlobalAccess().getRule();
	}
	
	//Interstice: fg = (FlattenOrGlobal);
	public IntersticeElements getIntersticeAccess() {
		return pInterstice;
	}
	
	public ParserRule getIntersticeRule() {
		return getIntersticeAccess().getRule();
	}
	
	//Classification: drop =(Dropout)? d=('dense') ;
	public ClassificationElements getClassificationAccess() {
		return pClassification;
	}
	
	public ParserRule getClassificationRule() {
		return getClassificationAccess().getRule();
	}
	
	//ConvDrop: conv = Convolution (drop = Dropout)?;
	public ConvDropElements getConvDropAccess() {
		return pConvDrop;
	}
	
	public ParserRule getConvDropRule() {
		return getConvDropAccess().getRule();
	}
	
	//// Merge Recursive
	//LeftRecu: (p=Pooling)? convdropbegin += (ConvDrop)* (merge = Merge) convdropend += (ConvDrop)* (pool=Pooling)?
	//;
	public LeftRecuElements getLeftRecuAccess() {
		return pLeftRecu;
	}
	
	public ParserRule getLeftRecuRule() {
		return getLeftRecuAccess().getRule();
	}
	
	//MergeRecu:  db = DebutMerge left = LeftRecu virg=','  right = Right  fm = FinMerge ;
	public MergeRecuElements getMergeRecuAccess() {
		return pMergeRecu;
	}
	
	public ParserRule getMergeRecuRule() {
		return getMergeRecuAccess().getRule();
	}
	
	//// Merge Non recusive
	//LeftNonRecursive: p = (Pooling)? convdrop += (ConvDrop)+ pool = (Pooling)?;
	public LeftNonRecursiveElements getLeftNonRecursiveAccess() {
		return pLeftNonRecursive;
	}
	
	public ParserRule getLeftNonRecursiveRule() {
		return getLeftNonRecursiveAccess().getRule();
	}
	
	//Right: conv += Convolution+ | {Right} empty = 'Empty';
	public RightElements getRightAccess() {
		return pRight;
	}
	
	public ParserRule getRightRule() {
		return getRightAccess().getRule();
	}
	
	//MergeNonRecu: db = DebutMerge leftNonRec = LeftNonRecursive virg=','  right = Right fm = FinMerge;
	public MergeNonRecuElements getMergeNonRecuAccess() {
		return pMergeNonRecu;
	}
	
	public ParserRule getMergeNonRecuRule() {
		return getMergeNonRecuAccess().getRule();
	}
	
	//// Merge
	//Merge: mnr = MergeNonRecu | mr = MergeRecu;
	public MergeElements getMergeAccess() {
		return pMerge;
	}
	
	public ParserRule getMergeRule() {
		return getMergeAccess().getRule();
	}
	
	//Highway: (db += DebutMerge) ((leftNonRec+=LeftNonRecursive) ('|') (conv += Convolution) (','))+ (fm += FinMerge);
	public HighwayElements getHighwayAccess() {
		return pHighway;
	}
	
	public ParserRule getHighwayRule() {
		return getHighwayAccess().getRule();
	}
	
	////Feature extraction
	//FeatureExtraction:     (conv = Convolution | merge = (Merge) | hw = (Highway)) drop = (Dropout)? pool= (Pooling)?;
	public FeatureExtractionElements getFeatureExtractionAccess() {
		return pFeatureExtraction;
	}
	
	public ParserRule getFeatureExtractionRule() {
		return getFeatureExtractionAccess().getRule();
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
