/*
 * generated by Xtext 2.25.0
 */
grammar InternalSML;

options {
	superClass=AbstractInternalAntlrParser;
}

@lexer::header {
package xtext.parser.antlr.internal;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}

@parser::header {
package xtext.parser.antlr.internal;

import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
import xtext.services.SMLGrammarAccess;

}

@parser::members {

 	private SMLGrammarAccess grammarAccess;

    public InternalSMLParser(TokenStream input, SMLGrammarAccess grammarAccess) {
        this(input);
        this.grammarAccess = grammarAccess;
        registerRules(grammarAccess.getGrammar());
    }

    @Override
    protected String getFirstRuleName() {
    	return "SML";
   	}

   	@Override
   	protected SMLGrammarAccess getGrammarAccess() {
   		return grammarAccess;
   	}

}

@rulecatch {
    catch (RecognitionException re) {
        recover(input,re);
        appendSkippedTokens();
    }
}

// Entry rule entryRuleSML
entryRuleSML returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getSMLRule()); }
	iv_ruleSML=ruleSML
	{ $current=$iv_ruleSML.current; }
	EOF;

// Rule SML
ruleSML returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getSMLAccess().getSmlArchitectureParserRuleCall_0());
			}
			lv_sml_0_0=ruleArchitecture
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getSMLRule());
				}
				set(
					$current,
					"sml",
					lv_sml_0_0,
					"xtext.SML.Architecture");
				afterParserOrEnumRuleCall();
			}
		)
	)
;

// Entry rule entryRuleArchitecture
entryRuleArchitecture returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getArchitectureRule()); }
	iv_ruleArchitecture=ruleArchitecture
	{ $current=$iv_ruleArchitecture.current; }
	EOF;

// Rule Architecture
ruleArchitecture returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				lv_input_0_0='input'
				{
					newLeafNode(lv_input_0_0, grammarAccess.getArchitectureAccess().getInputInputKeyword_0_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getArchitectureRule());
					}
					setWithLastConsumed($current, "input", lv_input_0_0, "input");
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getArchitectureAccess().getFeFeatureExtractionParserRuleCall_1_0());
				}
				lv_fe_1_0=ruleFeatureExtraction
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getArchitectureRule());
					}
					add(
						$current,
						"fe",
						lv_fe_1_0,
						"xtext.SML.FeatureExtraction");
					afterParserOrEnumRuleCall();
				}
			)
		)+
		(
			(
				(
					{
						newCompositeNode(grammarAccess.getArchitectureAccess().getInterIntersticeParserRuleCall_2_0_0());
					}
					lv_inter_2_0=ruleInterstice
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getArchitectureRule());
						}
						set(
							$current,
							"inter",
							lv_inter_2_0,
							"xtext.SML.Interstice");
						afterParserOrEnumRuleCall();
					}
				)
			)
			(
				(
					{
						newCompositeNode(grammarAccess.getArchitectureAccess().getClassClassificationParserRuleCall_2_1_0());
					}
					lv_class_3_0=ruleClassification
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getArchitectureRule());
						}
						add(
							$current,
							"class",
							lv_class_3_0,
							"xtext.SML.Classification");
						afterParserOrEnumRuleCall();
					}
				)
			)*
		)?
		(
			(
				lv_output_4_0='output'
				{
					newLeafNode(lv_output_4_0, grammarAccess.getArchitectureAccess().getOutputOutputKeyword_3_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getArchitectureRule());
					}
					setWithLastConsumed($current, "output", lv_output_4_0, "output");
				}
			)
		)
	)
;

// Entry rule entryRuleDropout
entryRuleDropout returns [String current=null]:
	{ newCompositeNode(grammarAccess.getDropoutRule()); }
	iv_ruleDropout=ruleDropout
	{ $current=$iv_ruleDropout.current.getText(); }
	EOF;

// Rule Dropout
ruleDropout returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='dropout'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getDropoutAccess().getDropoutKeyword());
	}
;

// Entry rule entryRulePooling
entryRulePooling returns [String current=null]:
	{ newCompositeNode(grammarAccess.getPoolingRule()); }
	iv_rulePooling=rulePooling
	{ $current=$iv_rulePooling.current.getText(); }
	EOF;

// Rule Pooling
rulePooling returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		kw='avg_pooling'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getPoolingAccess().getAvg_poolingKeyword_0());
		}
		    |
		kw='max_pooling'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getPoolingAccess().getMax_poolingKeyword_1());
		}
	)
;

// Entry rule entryRuleDebutMerge
entryRuleDebutMerge returns [String current=null]:
	{ newCompositeNode(grammarAccess.getDebutMergeRule()); }
	iv_ruleDebutMerge=ruleDebutMerge
	{ $current=$iv_ruleDebutMerge.current.getText(); }
	EOF;

// Rule DebutMerge
ruleDebutMerge returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw='['
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getDebutMergeAccess().getLeftSquareBracketKeyword());
	}
;

// Entry rule entryRuleFinMerge
entryRuleFinMerge returns [String current=null]:
	{ newCompositeNode(grammarAccess.getFinMergeRule()); }
	iv_ruleFinMerge=ruleFinMerge
	{ $current=$iv_ruleFinMerge.current.getText(); }
	EOF;

// Rule FinMerge
ruleFinMerge returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	kw=']'
	{
		$current.merge(kw);
		newLeafNode(kw, grammarAccess.getFinMergeAccess().getRightSquareBracketKeyword());
	}
;

// Entry rule entryRuleBnConv
entryRuleBnConv returns [String current=null]:
	{ newCompositeNode(grammarAccess.getBnConvRule()); }
	iv_ruleBnConv=ruleBnConv
	{ $current=$iv_ruleBnConv.current.getText(); }
	EOF;

// Rule BnConv
ruleBnConv returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		kw='('
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getBnConvAccess().getLeftParenthesisKeyword_0());
		}
		kw='bn'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getBnConvAccess().getBnKeyword_1());
		}
		kw='conv'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getBnConvAccess().getConvKeyword_2());
		}
		kw=')'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getBnConvAccess().getRightParenthesisKeyword_3());
		}
	)
;

// Entry rule entryRuleConvBn
entryRuleConvBn returns [String current=null]:
	{ newCompositeNode(grammarAccess.getConvBnRule()); }
	iv_ruleConvBn=ruleConvBn
	{ $current=$iv_ruleConvBn.current.getText(); }
	EOF;

// Rule ConvBn
ruleConvBn returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		kw='('
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getConvBnAccess().getLeftParenthesisKeyword_0());
		}
		kw='conv'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getConvBnAccess().getConvKeyword_1());
		}
		kw='bn'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getConvBnAccess().getBnKeyword_2());
		}
		kw=')'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getConvBnAccess().getRightParenthesisKeyword_3());
		}
	)
;

// Entry rule entryRuleConvolution
entryRuleConvolution returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getConvolutionRule()); }
	iv_ruleConvolution=ruleConvolution
	{ $current=$iv_ruleConvolution.current; }
	EOF;

// Rule Convolution
ruleConvolution returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getConvolutionAccess().getBnconvBnConvParserRuleCall_0_0());
				}
				lv_bnconv_0_0=ruleBnConv
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getConvolutionRule());
					}
					set(
						$current,
						"bnconv",
						lv_bnconv_0_0,
						"xtext.SML.BnConv");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getConvolutionAccess().getConvbnConvBnParserRuleCall_1_0());
				}
				lv_convbn_1_0=ruleConvBn
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getConvolutionRule());
					}
					set(
						$current,
						"convbn",
						lv_convbn_1_0,
						"xtext.SML.ConvBn");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				lv_conv_2_0='conv'
				{
					newLeafNode(lv_conv_2_0, grammarAccess.getConvolutionAccess().getConvConvKeyword_2_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getConvolutionRule());
					}
					setWithLastConsumed($current, "conv", lv_conv_2_0, "conv");
				}
			)
		)
		    |
		(
			(
				lv_upconv_3_0='upconv'
				{
					newLeafNode(lv_upconv_3_0, grammarAccess.getConvolutionAccess().getUpconvUpconvKeyword_3_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getConvolutionRule());
					}
					setWithLastConsumed($current, "upconv", lv_upconv_3_0, "upconv");
				}
			)
		)
	)
;

// Entry rule entryRuleGlobalPooling
entryRuleGlobalPooling returns [String current=null]:
	{ newCompositeNode(grammarAccess.getGlobalPoolingRule()); }
	iv_ruleGlobalPooling=ruleGlobalPooling
	{ $current=$iv_ruleGlobalPooling.current.getText(); }
	EOF;

// Rule GlobalPooling
ruleGlobalPooling returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		kw='global_avg_pooling'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getGlobalPoolingAccess().getGlobal_avg_poolingKeyword_0());
		}
		    |
		kw='global_max_pooling'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getGlobalPoolingAccess().getGlobal_max_poolingKeyword_1());
		}
	)
;

// Entry rule entryRuleFlattenOrGlobal
entryRuleFlattenOrGlobal returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getFlattenOrGlobalRule()); }
	iv_ruleFlattenOrGlobal=ruleFlattenOrGlobal
	{ $current=$iv_ruleFlattenOrGlobal.current; }
	EOF;

// Rule FlattenOrGlobal
ruleFlattenOrGlobal returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				lv_flat_0_0='flatten'
				{
					newLeafNode(lv_flat_0_0, grammarAccess.getFlattenOrGlobalAccess().getFlatFlattenKeyword_0_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getFlattenOrGlobalRule());
					}
					setWithLastConsumed($current, "flat", lv_flat_0_0, "flatten");
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getFlattenOrGlobalAccess().getGpGlobalPoolingParserRuleCall_1_0());
				}
				lv_gp_1_0=ruleGlobalPooling
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFlattenOrGlobalRule());
					}
					set(
						$current,
						"gp",
						lv_gp_1_0,
						"xtext.SML.GlobalPooling");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleInterstice
entryRuleInterstice returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getIntersticeRule()); }
	iv_ruleInterstice=ruleInterstice
	{ $current=$iv_ruleInterstice.current; }
	EOF;

// Rule Interstice
ruleInterstice returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getIntersticeAccess().getFgFlattenOrGlobalParserRuleCall_0());
			}
			lv_fg_0_0=ruleFlattenOrGlobal
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getIntersticeRule());
				}
				set(
					$current,
					"fg",
					lv_fg_0_0,
					"xtext.SML.FlattenOrGlobal");
				afterParserOrEnumRuleCall();
			}
		)
	)
;

// Entry rule entryRuleClassification
entryRuleClassification returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getClassificationRule()); }
	iv_ruleClassification=ruleClassification
	{ $current=$iv_ruleClassification.current; }
	EOF;

// Rule Classification
ruleClassification returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getClassificationAccess().getDropDropoutParserRuleCall_0_0());
				}
				lv_drop_0_0=ruleDropout
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getClassificationRule());
					}
					set(
						$current,
						"drop",
						lv_drop_0_0,
						"xtext.SML.Dropout");
					afterParserOrEnumRuleCall();
				}
			)
		)?
		(
			(
				lv_d_1_0='dense'
				{
					newLeafNode(lv_d_1_0, grammarAccess.getClassificationAccess().getDDenseKeyword_1_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getClassificationRule());
					}
					setWithLastConsumed($current, "d", lv_d_1_0, "dense");
				}
			)
		)
	)
;

// Entry rule entryRuleConvDrop
entryRuleConvDrop returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getConvDropRule()); }
	iv_ruleConvDrop=ruleConvDrop
	{ $current=$iv_ruleConvDrop.current; }
	EOF;

// Rule ConvDrop
ruleConvDrop returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getConvDropAccess().getConvConvolutionParserRuleCall_0_0());
				}
				lv_conv_0_0=ruleConvolution
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getConvDropRule());
					}
					set(
						$current,
						"conv",
						lv_conv_0_0,
						"xtext.SML.Convolution");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getConvDropAccess().getDropDropoutParserRuleCall_1_0());
				}
				lv_drop_1_0=ruleDropout
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getConvDropRule());
					}
					set(
						$current,
						"drop",
						lv_drop_1_0,
						"xtext.SML.Dropout");
					afterParserOrEnumRuleCall();
				}
			)
		)?
	)
;

// Entry rule entryRuleLeftRecu
entryRuleLeftRecu returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getLeftRecuRule()); }
	iv_ruleLeftRecu=ruleLeftRecu
	{ $current=$iv_ruleLeftRecu.current; }
	EOF;

// Rule LeftRecu
ruleLeftRecu returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getLeftRecuAccess().getPPoolingParserRuleCall_0_0());
				}
				lv_p_0_0=rulePooling
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLeftRecuRule());
					}
					set(
						$current,
						"p",
						lv_p_0_0,
						"xtext.SML.Pooling");
					afterParserOrEnumRuleCall();
				}
			)
		)?
		(
			(
				{
					newCompositeNode(grammarAccess.getLeftRecuAccess().getConvdropbeginConvDropParserRuleCall_1_0());
				}
				lv_convdropbegin_1_0=ruleConvDrop
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLeftRecuRule());
					}
					add(
						$current,
						"convdropbegin",
						lv_convdropbegin_1_0,
						"xtext.SML.ConvDrop");
					afterParserOrEnumRuleCall();
				}
			)
		)*
		(
			(
				{
					newCompositeNode(grammarAccess.getLeftRecuAccess().getMergeMergeParserRuleCall_2_0());
				}
				lv_merge_2_0=ruleMerge
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLeftRecuRule());
					}
					set(
						$current,
						"merge",
						lv_merge_2_0,
						"xtext.SML.Merge");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getLeftRecuAccess().getConvdropendConvDropParserRuleCall_3_0());
				}
				lv_convdropend_3_0=ruleConvDrop
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLeftRecuRule());
					}
					add(
						$current,
						"convdropend",
						lv_convdropend_3_0,
						"xtext.SML.ConvDrop");
					afterParserOrEnumRuleCall();
				}
			)
		)*
		(
			(
				{
					newCompositeNode(grammarAccess.getLeftRecuAccess().getPoolPoolingParserRuleCall_4_0());
				}
				lv_pool_4_0=rulePooling
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLeftRecuRule());
					}
					set(
						$current,
						"pool",
						lv_pool_4_0,
						"xtext.SML.Pooling");
					afterParserOrEnumRuleCall();
				}
			)
		)?
	)
;

// Entry rule entryRuleMergeRecu
entryRuleMergeRecu returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getMergeRecuRule()); }
	iv_ruleMergeRecu=ruleMergeRecu
	{ $current=$iv_ruleMergeRecu.current; }
	EOF;

// Rule MergeRecu
ruleMergeRecu returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getMergeRecuAccess().getDbDebutMergeParserRuleCall_0_0());
				}
				lv_db_0_0=ruleDebutMerge
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getMergeRecuRule());
					}
					set(
						$current,
						"db",
						lv_db_0_0,
						"xtext.SML.DebutMerge");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getMergeRecuAccess().getLeftLeftRecuParserRuleCall_1_0());
				}
				lv_left_1_0=ruleLeftRecu
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getMergeRecuRule());
					}
					set(
						$current,
						"left",
						lv_left_1_0,
						"xtext.SML.LeftRecu");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				lv_virg_2_0=','
				{
					newLeafNode(lv_virg_2_0, grammarAccess.getMergeRecuAccess().getVirgCommaKeyword_2_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getMergeRecuRule());
					}
					setWithLastConsumed($current, "virg", lv_virg_2_0, ",");
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getMergeRecuAccess().getRightRightParserRuleCall_3_0());
				}
				lv_right_3_0=ruleRight
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getMergeRecuRule());
					}
					set(
						$current,
						"right",
						lv_right_3_0,
						"xtext.SML.Right");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getMergeRecuAccess().getFmFinMergeParserRuleCall_4_0());
				}
				lv_fm_4_0=ruleFinMerge
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getMergeRecuRule());
					}
					set(
						$current,
						"fm",
						lv_fm_4_0,
						"xtext.SML.FinMerge");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleLeftNonRecursive
entryRuleLeftNonRecursive returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getLeftNonRecursiveRule()); }
	iv_ruleLeftNonRecursive=ruleLeftNonRecursive
	{ $current=$iv_ruleLeftNonRecursive.current; }
	EOF;

// Rule LeftNonRecursive
ruleLeftNonRecursive returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getLeftNonRecursiveAccess().getPPoolingParserRuleCall_0_0());
				}
				lv_p_0_0=rulePooling
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLeftNonRecursiveRule());
					}
					set(
						$current,
						"p",
						lv_p_0_0,
						"xtext.SML.Pooling");
					afterParserOrEnumRuleCall();
				}
			)
		)?
		(
			(
				{
					newCompositeNode(grammarAccess.getLeftNonRecursiveAccess().getConvdropConvDropParserRuleCall_1_0());
				}
				lv_convdrop_1_0=ruleConvDrop
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLeftNonRecursiveRule());
					}
					add(
						$current,
						"convdrop",
						lv_convdrop_1_0,
						"xtext.SML.ConvDrop");
					afterParserOrEnumRuleCall();
				}
			)
		)+
		(
			(
				{
					newCompositeNode(grammarAccess.getLeftNonRecursiveAccess().getPoolPoolingParserRuleCall_2_0());
				}
				lv_pool_2_0=rulePooling
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getLeftNonRecursiveRule());
					}
					set(
						$current,
						"pool",
						lv_pool_2_0,
						"xtext.SML.Pooling");
					afterParserOrEnumRuleCall();
				}
			)
		)?
	)
;

// Entry rule entryRuleRight
entryRuleRight returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getRightRule()); }
	iv_ruleRight=ruleRight
	{ $current=$iv_ruleRight.current; }
	EOF;

// Rule Right
ruleRight returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getRightAccess().getConvConvolutionParserRuleCall_0_0());
				}
				lv_conv_0_0=ruleConvolution
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getRightRule());
					}
					add(
						$current,
						"conv",
						lv_conv_0_0,
						"xtext.SML.Convolution");
					afterParserOrEnumRuleCall();
				}
			)
		)+
		    |
		(
			(
				{
					$current = forceCreateModelElement(
						grammarAccess.getRightAccess().getRightAction_1_0(),
						$current);
				}
			)
			otherlv_2='Empty'
			{
				newLeafNode(otherlv_2, grammarAccess.getRightAccess().getEmptyKeyword_1_1());
			}
		)
	)
;

// Entry rule entryRuleMergeNonRecu
entryRuleMergeNonRecu returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getMergeNonRecuRule()); }
	iv_ruleMergeNonRecu=ruleMergeNonRecu
	{ $current=$iv_ruleMergeNonRecu.current; }
	EOF;

// Rule MergeNonRecu
ruleMergeNonRecu returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getMergeNonRecuAccess().getDbDebutMergeParserRuleCall_0_0());
				}
				lv_db_0_0=ruleDebutMerge
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getMergeNonRecuRule());
					}
					set(
						$current,
						"db",
						lv_db_0_0,
						"xtext.SML.DebutMerge");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getMergeNonRecuAccess().getLeftNonRecLeftNonRecursiveParserRuleCall_1_0());
				}
				lv_leftNonRec_1_0=ruleLeftNonRecursive
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getMergeNonRecuRule());
					}
					set(
						$current,
						"leftNonRec",
						lv_leftNonRec_1_0,
						"xtext.SML.LeftNonRecursive");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				lv_virg_2_0=','
				{
					newLeafNode(lv_virg_2_0, grammarAccess.getMergeNonRecuAccess().getVirgCommaKeyword_2_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getMergeNonRecuRule());
					}
					setWithLastConsumed($current, "virg", lv_virg_2_0, ",");
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getMergeNonRecuAccess().getRightRightParserRuleCall_3_0());
				}
				lv_right_3_0=ruleRight
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getMergeNonRecuRule());
					}
					set(
						$current,
						"right",
						lv_right_3_0,
						"xtext.SML.Right");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getMergeNonRecuAccess().getFmFinMergeParserRuleCall_4_0());
				}
				lv_fm_4_0=ruleFinMerge
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getMergeNonRecuRule());
					}
					set(
						$current,
						"fm",
						lv_fm_4_0,
						"xtext.SML.FinMerge");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleMerge
entryRuleMerge returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getMergeRule()); }
	iv_ruleMerge=ruleMerge
	{ $current=$iv_ruleMerge.current; }
	EOF;

// Rule Merge
ruleMerge returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getMergeAccess().getMnrMergeNonRecuParserRuleCall_0_0());
				}
				lv_mnr_0_0=ruleMergeNonRecu
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getMergeRule());
					}
					set(
						$current,
						"mnr",
						lv_mnr_0_0,
						"xtext.SML.MergeNonRecu");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getMergeAccess().getMrMergeRecuParserRuleCall_1_0());
				}
				lv_mr_1_0=ruleMergeRecu
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getMergeRule());
					}
					set(
						$current,
						"mr",
						lv_mr_1_0,
						"xtext.SML.MergeRecu");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleHighway
entryRuleHighway returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getHighwayRule()); }
	iv_ruleHighway=ruleHighway
	{ $current=$iv_ruleHighway.current; }
	EOF;

// Rule Highway
ruleHighway returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getHighwayAccess().getDbDebutMergeParserRuleCall_0_0());
				}
				lv_db_0_0=ruleDebutMerge
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getHighwayRule());
					}
					add(
						$current,
						"db",
						lv_db_0_0,
						"xtext.SML.DebutMerge");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				(
					{
						newCompositeNode(grammarAccess.getHighwayAccess().getLeftNonRecLeftNonRecursiveParserRuleCall_1_0_0());
					}
					lv_leftNonRec_1_0=ruleLeftNonRecursive
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getHighwayRule());
						}
						add(
							$current,
							"leftNonRec",
							lv_leftNonRec_1_0,
							"xtext.SML.LeftNonRecursive");
						afterParserOrEnumRuleCall();
					}
				)
			)
			otherlv_2='|'
			{
				newLeafNode(otherlv_2, grammarAccess.getHighwayAccess().getVerticalLineKeyword_1_1());
			}
			(
				(
					{
						newCompositeNode(grammarAccess.getHighwayAccess().getConvConvolutionParserRuleCall_1_2_0());
					}
					lv_conv_3_0=ruleConvolution
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getHighwayRule());
						}
						add(
							$current,
							"conv",
							lv_conv_3_0,
							"xtext.SML.Convolution");
						afterParserOrEnumRuleCall();
					}
				)
			)
			otherlv_4=','
			{
				newLeafNode(otherlv_4, grammarAccess.getHighwayAccess().getCommaKeyword_1_3());
			}
		)+
		(
			(
				{
					newCompositeNode(grammarAccess.getHighwayAccess().getFmFinMergeParserRuleCall_2_0());
				}
				lv_fm_5_0=ruleFinMerge
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getHighwayRule());
					}
					add(
						$current,
						"fm",
						lv_fm_5_0,
						"xtext.SML.FinMerge");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleFeatureExtraction
entryRuleFeatureExtraction returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getFeatureExtractionRule()); }
	iv_ruleFeatureExtraction=ruleFeatureExtraction
	{ $current=$iv_ruleFeatureExtraction.current; }
	EOF;

// Rule FeatureExtraction
ruleFeatureExtraction returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				(
					{
						newCompositeNode(grammarAccess.getFeatureExtractionAccess().getConvConvolutionParserRuleCall_0_0_0());
					}
					lv_conv_0_0=ruleConvolution
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getFeatureExtractionRule());
						}
						set(
							$current,
							"conv",
							lv_conv_0_0,
							"xtext.SML.Convolution");
						afterParserOrEnumRuleCall();
					}
				)
			)
			    |
			(
				(
					{
						newCompositeNode(grammarAccess.getFeatureExtractionAccess().getMergeMergeParserRuleCall_0_1_0());
					}
					lv_merge_1_0=ruleMerge
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getFeatureExtractionRule());
						}
						set(
							$current,
							"merge",
							lv_merge_1_0,
							"xtext.SML.Merge");
						afterParserOrEnumRuleCall();
					}
				)
			)
			    |
			(
				(
					{
						newCompositeNode(grammarAccess.getFeatureExtractionAccess().getHwHighwayParserRuleCall_0_2_0());
					}
					lv_hw_2_0=ruleHighway
					{
						if ($current==null) {
							$current = createModelElementForParent(grammarAccess.getFeatureExtractionRule());
						}
						set(
							$current,
							"hw",
							lv_hw_2_0,
							"xtext.SML.Highway");
						afterParserOrEnumRuleCall();
					}
				)
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getFeatureExtractionAccess().getDropDropoutParserRuleCall_1_0());
				}
				lv_drop_3_0=ruleDropout
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFeatureExtractionRule());
					}
					set(
						$current,
						"drop",
						lv_drop_3_0,
						"xtext.SML.Dropout");
					afterParserOrEnumRuleCall();
				}
			)
		)?
		(
			(
				{
					newCompositeNode(grammarAccess.getFeatureExtractionAccess().getPoolPoolingParserRuleCall_2_0());
				}
				lv_pool_4_0=rulePooling
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getFeatureExtractionRule());
					}
					set(
						$current,
						"pool",
						lv_pool_4_0,
						"xtext.SML.Pooling");
					afterParserOrEnumRuleCall();
				}
			)
		)?
	)
;

RULE_ID : '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

RULE_INT : ('0'..'9')+;

RULE_STRING : ('"' ('\\' .|~(('\\'|'"')))* '"'|'\'' ('\\' .|~(('\\'|'\'')))* '\'');

RULE_ML_COMMENT : '/*' ( options {greedy=false;} : . )*'*/';

RULE_SL_COMMENT : '//' ~(('\n'|'\r'))* ('\r'? '\n')?;

RULE_WS : (' '|'\t'|'\r'|'\n')+;

RULE_ANY_OTHER : .;
