/*
 * generated by Xtext 2.25.0
 */
package xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.sML.Architecture;
import xtext.sML.Classification;
import xtext.sML.ConvDrop;
import xtext.sML.Convolution;
import xtext.sML.FeatureExtraction;
import xtext.sML.FlattenOrGlobal;
import xtext.sML.Highway;
import xtext.sML.Interstice;
import xtext.sML.LeftNonRecursive;
import xtext.sML.LeftRecu;
import xtext.sML.Merge;
import xtext.sML.MergeNonRecu;
import xtext.sML.MergeRecu;
import xtext.sML.Right;
import xtext.sML.SML;
import xtext.sML.SMLPackage;
import xtext.services.SMLGrammarAccess;

@SuppressWarnings("all")
public class SMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SMLPackage.ARCHITECTURE:
				sequence_Architecture(context, (Architecture) semanticObject); 
				return; 
			case SMLPackage.CLASSIFICATION:
				sequence_Classification(context, (Classification) semanticObject); 
				return; 
			case SMLPackage.CONV_DROP:
				sequence_ConvDrop(context, (ConvDrop) semanticObject); 
				return; 
			case SMLPackage.CONVOLUTION:
				sequence_Convolution(context, (Convolution) semanticObject); 
				return; 
			case SMLPackage.FEATURE_EXTRACTION:
				sequence_FeatureExtraction(context, (FeatureExtraction) semanticObject); 
				return; 
			case SMLPackage.FLATTEN_OR_GLOBAL:
				sequence_FlattenOrGlobal(context, (FlattenOrGlobal) semanticObject); 
				return; 
			case SMLPackage.HIGHWAY:
				sequence_Highway(context, (Highway) semanticObject); 
				return; 
			case SMLPackage.INTERSTICE:
				sequence_Interstice(context, (Interstice) semanticObject); 
				return; 
			case SMLPackage.LEFT_NON_RECURSIVE:
				sequence_LeftNonRecursive(context, (LeftNonRecursive) semanticObject); 
				return; 
			case SMLPackage.LEFT_RECU:
				sequence_LeftRecu(context, (LeftRecu) semanticObject); 
				return; 
			case SMLPackage.MERGE:
				sequence_Merge(context, (Merge) semanticObject); 
				return; 
			case SMLPackage.MERGE_NON_RECU:
				sequence_MergeNonRecu(context, (MergeNonRecu) semanticObject); 
				return; 
			case SMLPackage.MERGE_RECU:
				sequence_MergeRecu(context, (MergeRecu) semanticObject); 
				return; 
			case SMLPackage.RIGHT:
				sequence_Right(context, (Right) semanticObject); 
				return; 
			case SMLPackage.SML:
				sequence_SML(context, (SML) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Architecture returns Architecture
	 *
	 * Constraint:
	 *     (input='input' fe+=FeatureExtraction+ (inter=Interstice class+=Classification*)? output='output')
	 */
	protected void sequence_Architecture(ISerializationContext context, Architecture semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classification returns Classification
	 *
	 * Constraint:
	 *     (drop=Dropout? d='dense')
	 */
	protected void sequence_Classification(ISerializationContext context, Classification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConvDrop returns ConvDrop
	 *
	 * Constraint:
	 *     (conv=Convolution drop=Dropout?)
	 */
	protected void sequence_ConvDrop(ISerializationContext context, ConvDrop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Convolution returns Convolution
	 *
	 * Constraint:
	 *     (bnconv=BnConv | convbn=ConvBn | conv='conv' | upconv='upconv')
	 */
	protected void sequence_Convolution(ISerializationContext context, Convolution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureExtraction returns FeatureExtraction
	 *
	 * Constraint:
	 *     ((conv=Convolution | merge=Merge | hw=Highway) drop=Dropout? pool=Pooling?)
	 */
	protected void sequence_FeatureExtraction(ISerializationContext context, FeatureExtraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FlattenOrGlobal returns FlattenOrGlobal
	 *
	 * Constraint:
	 *     (flat='flatten' | gp=GlobalPooling)
	 */
	protected void sequence_FlattenOrGlobal(ISerializationContext context, FlattenOrGlobal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Highway returns Highway
	 *
	 * Constraint:
	 *     (db+=DebutMerge (leftNonRec+=LeftNonRecursive conv+=Convolution)+ fm+=FinMerge)
	 */
	protected void sequence_Highway(ISerializationContext context, Highway semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Interstice returns Interstice
	 *
	 * Constraint:
	 *     fg=FlattenOrGlobal
	 */
	protected void sequence_Interstice(ISerializationContext context, Interstice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.INTERSTICE__FG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.INTERSTICE__FG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntersticeAccess().getFgFlattenOrGlobalParserRuleCall_0(), semanticObject.getFg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LeftNonRecursive returns LeftNonRecursive
	 *
	 * Constraint:
	 *     (p=Pooling? convdrop+=ConvDrop+ pool=Pooling?)
	 */
	protected void sequence_LeftNonRecursive(ISerializationContext context, LeftNonRecursive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftRecu returns LeftRecu
	 *
	 * Constraint:
	 *     (p=Pooling? convdropbegin+=ConvDrop* merge=Merge convdropend+=ConvDrop* pool=Pooling?)
	 */
	protected void sequence_LeftRecu(ISerializationContext context, LeftRecu semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MergeNonRecu returns MergeNonRecu
	 *
	 * Constraint:
	 *     (db=DebutMerge leftNonRec=LeftNonRecursive virg=',' right=Right fm=FinMerge)
	 */
	protected void sequence_MergeNonRecu(ISerializationContext context, MergeNonRecu semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.MERGE_NON_RECU__DB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.MERGE_NON_RECU__DB));
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.MERGE_NON_RECU__LEFT_NON_REC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.MERGE_NON_RECU__LEFT_NON_REC));
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.MERGE_NON_RECU__VIRG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.MERGE_NON_RECU__VIRG));
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.MERGE_NON_RECU__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.MERGE_NON_RECU__RIGHT));
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.MERGE_NON_RECU__FM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.MERGE_NON_RECU__FM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMergeNonRecuAccess().getDbDebutMergeParserRuleCall_0_0(), semanticObject.getDb());
		feeder.accept(grammarAccess.getMergeNonRecuAccess().getLeftNonRecLeftNonRecursiveParserRuleCall_1_0(), semanticObject.getLeftNonRec());
		feeder.accept(grammarAccess.getMergeNonRecuAccess().getVirgCommaKeyword_2_0(), semanticObject.getVirg());
		feeder.accept(grammarAccess.getMergeNonRecuAccess().getRightRightParserRuleCall_3_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getMergeNonRecuAccess().getFmFinMergeParserRuleCall_4_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MergeRecu returns MergeRecu
	 *
	 * Constraint:
	 *     (db=DebutMerge left=LeftRecu virg=',' right=Right fm=FinMerge)
	 */
	protected void sequence_MergeRecu(ISerializationContext context, MergeRecu semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.MERGE_RECU__DB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.MERGE_RECU__DB));
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.MERGE_RECU__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.MERGE_RECU__LEFT));
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.MERGE_RECU__VIRG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.MERGE_RECU__VIRG));
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.MERGE_RECU__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.MERGE_RECU__RIGHT));
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.MERGE_RECU__FM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.MERGE_RECU__FM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMergeRecuAccess().getDbDebutMergeParserRuleCall_0_0(), semanticObject.getDb());
		feeder.accept(grammarAccess.getMergeRecuAccess().getLeftLeftRecuParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMergeRecuAccess().getVirgCommaKeyword_2_0(), semanticObject.getVirg());
		feeder.accept(grammarAccess.getMergeRecuAccess().getRightRightParserRuleCall_3_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getMergeRecuAccess().getFmFinMergeParserRuleCall_4_0(), semanticObject.getFm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Merge returns Merge
	 *
	 * Constraint:
	 *     (mnr=MergeNonRecu | mr=MergeRecu)
	 */
	protected void sequence_Merge(ISerializationContext context, Merge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Right returns Right
	 *
	 * Constraint:
	 *     (conv+=Convolution+ | empty='Empty')
	 */
	protected void sequence_Right(ISerializationContext context, Right semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SML returns SML
	 *
	 * Constraint:
	 *     sml=Architecture
	 */
	protected void sequence_SML(ISerializationContext context, SML semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SMLPackage.Literals.SML__SML) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SMLPackage.Literals.SML__SML));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSMLAccess().getSmlArchitectureParserRuleCall_0(), semanticObject.getSml());
		feeder.finish();
	}
	
	
}
