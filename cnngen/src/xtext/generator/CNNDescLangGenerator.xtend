/*
 * generated by Xtext 2.26.0
 */
package xtext.generator

import controller.MainController
import domain.BatchNormalisation
import domain.Concatenate
import domain.Convolution
import domain.Dense
import domain.Dropout
import domain.Pooling
import java.io.PrintWriter
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import utils.FonctionStringPy
import utils.GestionWay
import utils.ProgramConfig
import views.ArchitectureGraphView
import xtext.cNNDescLang.Architecture
import xtext.cNNDescLang.CNNDescLang
import xtext.cNNDescLang.Classification
import xtext.cNNDescLang.FeatureExtraction
import xtext.cNNDescLang.Interstice
import xtext.cNNDescLang.Left
import xtext.cNNDescLang.Merge
import xtext.cNNDescLang.MergeBody
import xtext.cNNDescLang.Right
import xtext.cNNDescLang.impl.CNNDescLangFactoryImpl

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CNNDescLangGenerator extends AbstractGenerator {

	
	var countryISOCode = "BEL"

	var fsp = new FonctionStringPy()
	
	var GestionWay gestionWay = null //GestionWay.gestionWay
	
	MainController mainCtrl = null
	
	ArchitectureGraphView graphview = null;
	var currentPos = 1
		
	// python directory
    var py_dir = ""
    
   	/*
   	 * 
   	 * USING GENERATOR
   	 * 
   	 * 
   	 * 
   	*/
    // log directory
    var log_dir = ""
    
    // png directory
    var png_dir = ""
    
    var tensorboardDir = ""
    
    var emission_dir = ""
    
    // csv directory
    var csvDir = "";
    
    var ProgramConfig progConf = null
    
    
    /*
     * 
     * USING MANUAL CONSTRUCTION
     * 
     */
    /* 
    // log directory
    var log_dir = "../architecture_log/"
    
    // png directory
    var png_dir = "../architecture_img/"
    
    // csv directory
    static String csvDir = "../architecture_csv/";
     */
    
    var isES = false;
    var isTB = false;
    
	var file_name = ""
	
	var exp_dir = ""
	
	var CNNDescLangFactoryImpl factory = new CNNDescLangFactoryImpl()
	
	//var str_stride = ""
    
	// entry for ui
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		println(resource.URI)
		file_name = "architecture"
		mainCtrl = new MainController
		for(elem : resource.allContents.toIterable.filter(Architecture)){
			fsa.generateFile(py_dir + file_name + '.py', elem.compile())
		}
	}
	
	// entry for generator
	def void generate(CNNDescLang cnndl, String filename, String expDir, ProgramConfig programConfig ) {
		
		progConf = programConfig
		
		py_dir = progConf.pyDir
		log_dir = "../../" + progConf.logDir
		png_dir = "../../" + progConf.pngDir
		tensorboardDir = "../../" + progConf.tensorboardDir
		emission_dir = "../../" + progConf.emissionDir
		csvDir = "../../" + progConf.CSVDir
		isES = progConf.isEarlyStopping
		isTB = progConf.isTensorBoard
		
		exp_dir = expDir
		file_name = filename.split("/").last.split('.py').get(0)

		mainCtrl = new MainController(programConfig)	
		
		var archi = compile(cnndl.cnndesclang)
		
		
		var writer = new PrintWriter(filename, "UTF-8")
		writer.println(archi)
		writer.close()
		
		
	}
	
	// create py file
	private def compile(Architecture archi ){
		
		gestionWay = mainCtrl.gestionWay
		
		graphview = mainCtrl.graphview
		
		graphview.createGraph(archi)
		
		var adjMatrix = graphview.createAdjencyMatrix
		
		var writer = new PrintWriter(progConf.outputDir+progConf.adjacencyDir+exp_dir+file_name+".txt","UTF-8")
		writer.println(adjMatrix)
		writer.close()
		
		graphview.architectureHpp(mainCtrl.gestionHPP)
		


		var py_file = ""
		
		
		// write import
		py_file += fsp.strImport()

				
		if(progConf.dataset == "mnist")
			// write dataset minist
			py_file += fsp.writeMnistDataSet()
		else if (progConf.dataset == "cifar10")
			// write dataset cifar10
			py_file += fsp.writecifar10Dataset
		
		else throw new Exception("wtf")
		
		// write glo variable
		py_file += fsp.writeGlobalVariable(progConf.batchSize, progConf.epochs)
				
		// write init value 
		py_file += fsp.writeInitValue
		
		// write init code carbon
		py_file += fsp.writeInitTrackerCodeCarbon(countryISOCode, file_name, exp_dir, emission_dir)
		
		
		// try	
    	py_file += "try:\n"
		
		py_file += gestionArchi(archi)
		
		py_file += fsp.writeCallbackMethode(tensorboardDir + exp_dir + file_name, isES,isTB);
		
		py_file += fsp.writeStartCodeCarbonTracker
		
		py_file += fsp.writeTrain
		
		py_file += fsp.writeStopCodeCarbon
		
		py_file += fsp.gestionGood(log_dir + exp_dir, file_name)
		
		py_file += fsp.gestionError(log_dir + exp_dir, file_name)
		
		py_file += fsp.gestionFinally(csvDir + exp_dir, file_name, graphview.computeFlops)
		
		return py_file
		
	}
	
	private def gestionArchi(Architecture a){
		var str_archi = "\tdef getModel():\n"
		
		// verify input not missing
		if (!a.input.empty){
			str_archi += fsp.writeInput("[" + progConf.maxSizeImg + ","+ progConf.maxSizeImg + ","+ progConf.inputFilter +"]", gestionWay.current)
		}else{
			throw new Exception("missing Input")
		}
		
		// verify feature extraction not missing
		if (!a.fe.empty){
			str_archi += gestionFE(a.fe)
			//println(a.fe)

		}else{
			throw new Exception("missing feature extra")
		}

		
		if (a.inter !== null && a.class_ !== null){
			str_archi += gestionInter(a.inter)
			str_archi += gestionDense(a.class_)
		}
		
		
		if(!a.output.empty){
			str_archi += fsp.writeModel(gestionWay.current)
			
			// write : create png of the model
			str_archi += fsp.writeImg(png_dir, exp_dir, file_name)
    		
    		// write compile
    		str_archi += fsp.writeCompile
    		
		}else{
			throw new Exception("missing output")
		}
		
		return str_archi
	}
	
	def gestionFE(EList<FeatureExtraction> list) {
		var fe_string = ""
		for (elem: list){
			if (elem.conv !== null){
				fe_string += gestionConv(elem.conv, gestionWay.current)

			}else if (elem.merge !== null){
				fe_string += gestionMerge(elem.merge, true)
			}else {
				throw new Exception("gestionFe errors")
			}
			
			if (elem.drop !== null)
				fe_string += unitDropout(gestionWay.current)
			if (elem.pool !== null)
				fe_string += unitPooling(elem.pool, gestionWay.current)
		}
		return	fe_string
	}
	
	
	def gestionConv(xtext.cNNDescLang.Convolution conv, String x_or_shortcut) {
		if( conv.bnconv !== null)
			return unitBnConv(x_or_shortcut)
		else if (conv.convbn !== null)
			return unitConvBn(x_or_shortcut)
		else if (conv.conv !== null)
			return unitConv(x_or_shortcut)
		else return unitUpConv(x_or_shortcut)
	}
	
	def gestionMerge(Merge merge, boolean isRecu) {
		var str_merge = ""
		
		if(merge.mergeBody.size <= 1){
			str_merge += gestionMergeBody(merge.mergeBody.get(0), isRecu)
		}else {
			str_merge += gestionHighway(merge.mergeBody, isRecu)
		}
		
		return str_merge
	}
	
	def gestionHighway(EList<MergeBody> listMerge, boolean isRecu) {
		var str_highway = ""
		
		//init merge
		gestionWay.add
		str_highway += fsp.writeInitMerge(gestionWay.current, gestionWay.next)
		
		for (mb: listMerge){	
			// body merge (i.e Left & Right)
			str_highway += gestionLeft(mb.left,  false)
			str_highway += '\n'
			str_highway += gestionRight(mb.right, false)
			
			// end merge (i.e Add/Concatenate)
			//if(graph.getByID(currentPos) instanceof Concatenate){
			if (graphview.graph.get(currentPos) instanceof Concatenate){
			str_highway += fsp.writeConcat(gestionWay.current, gestionWay.next)
			}else{
				str_highway += fsp.writeAdd(gestionWay.current, gestionWay.next)
			}
			currentPos++
		}
		gestionWay.removeLastFromList
		
		return str_highway
	}
	
	def gestionMergeBody(MergeBody mb, boolean isRecu) {
		var strMergeBody = ""
	
		//init merge
		gestionWay.add
		strMergeBody += fsp.writeInitMerge(gestionWay.current, gestionWay.next)
		
		// body merge (i.e Left & Right)
		strMergeBody += gestionLeft(mb.left,  isRecu)
		strMergeBody += '\n'
		strMergeBody += gestionRight(mb.right,  isRecu)
		
		// end merge (i.e Add/Concatenate)
		//if(graph.getByID(currentPos) instanceof Concatenate){
		if (graphview.graph.get(currentPos) instanceof Concatenate){
			strMergeBody += fsp.writeConcat(gestionWay.current, gestionWay.next)
		}else{
			strMergeBody += fsp.writeAdd(gestionWay.current, gestionWay.next)
		}
		currentPos++
		gestionWay.removeLastFromList
		
		return strMergeBody
	}
	
	def gestionLeft(Left left, boolean isRecu) {
		var strLeft = ""
		if (left.p !== null){
			strLeft += unitPooling(left.p, gestionWay.current)
		}
		
		if (left.com.convdrop !== null){
			for (convdrop: left.com.convdrop){
				strLeft += gestionConv(convdrop.conv, gestionWay.current)
				
				if(convdrop.drop !== null){
					strLeft += unitDropout(gestionWay.current)
				}
			}
		}
		
		if(left.com.mergeConv !== null){
			
			for(mc : left.com.mergeConv){
				
				strLeft += gestionMerge(mc.merge, true)
				
				if (mc.convdrop !== null){
					for (convdrop: mc.convdrop){
						strLeft += gestionConv(convdrop.conv, gestionWay.current)
						if(convdrop.drop !== null)
							strLeft += unitDropout(gestionWay.current)
						}
				}
			}
		}
		
		if (left.pool !== null){
			strLeft += unitPooling(left.pool, gestionWay.current)
		}
		
		return strLeft
	}
	
	def gestionRight(Right right, boolean isRecu) {
		var strRight = ""
		
		if(right.conv !== null){
			for (conv: right.conv){
				strRight += gestionConv(conv, gestionWay.next)
			}
		}
		
		return strRight
	}
	
	
	def gestionInter(Interstice inter) {
		var string_inter = ""
		
		if (inter.fg.flat !== null){
			string_inter += unitFlatten(gestionWay.current)
		}else{
			string_inter += unitGlobalPooling(inter.fg.gp, gestionWay.current)
		}
			
		return string_inter
	}
	
	def gestionDense(EList<Classification> list) {
		var strDense = ""
		
		for(i: list){
			if(i.drop !== null)
				strDense += unitDropout(gestionWay.current)
			strDense += unitDense(gestionWay.current)
		}
		
		return strDense
	}
	

	
	// ===== Units =====
	
	def unitConv(String X_or_shortcut){
		var Convolution conv = graphview.getLayerByLayerpos(currentPos) as Convolution
		//var Convolution conv = graph.getByID(currentPos) as Convolution
		// str_stride += conv.stride + " "
		currentPos++
		return fsp.writeConv(conv.outputFilter, conv.kernel, conv.stride , conv.fctActivation, conv.padding, X_or_shortcut)
	}
	
	def unitUpConv(String X_or_shortcut){
		return fsp.writeUpconv(X_or_shortcut, 2)
	}
	
	def unitBnConv(String X_or_shortcut){
		var BatchNormalisation bn = graphview.getLayerByLayerpos(currentPos) as BatchNormalisation
		//var BatchNormalisation bn = graph.getByID(currentPos) as BatchNormalisation
		currentPos++
		
		var Convolution conv = graphview.getLayerByLayerpos(currentPos) as Convolution
		//var Convolution conv = graph.getByID(currentPos) as Convolution
		currentPos++
		// str_stride += conv.stride + " "
		
		return fsp.writeBN(bn.epsilon, X_or_shortcut) + fsp.writeConv(conv.outputFilter, conv.kernel, conv.stride , conv.fctActivation, conv.padding, X_or_shortcut)
	}
	
	def unitConvBn(String X_or_shortcut){
		var Convolution conv = graphview.getLayerByLayerpos(currentPos) as Convolution
		//var Convolution conv = graph.getByID(currentPos) as Convolution
		currentPos++
		
		var BatchNormalisation bn = graphview.getLayerByLayerpos(currentPos) as BatchNormalisation
		//var BatchNormalisation bn = graph.getByID(currentPos) as BatchNormalisation
		currentPos++
		// str_stride += conv.stride + " "
		return fsp.writeConv(conv.outputFilter, conv.kernel, conv.stride , conv.fctActivation, conv.padding, X_or_shortcut) + fsp.writeBN(bn.epsilon, X_or_shortcut)
	}
	
	 
	def unitPooling(String pool, String X_or_shortcut){
		var Pooling p = graphview.getLayerByLayerpos(currentPos) as Pooling
		//var Pooling p = graph.getByID(currentPos) as Pooling
		currentPos++
		if(pool == "avg_pooling"){
			return fsp.writeAvgPooling(p.kernel,p.stride,p.padding, X_or_shortcut)
		}else{
			return fsp.writeMaxPooling(p.kernel,p.stride,p.padding, X_or_shortcut)
		}
	}
	
	def unitDropout(String X_or_shortcut){
		var Dropout dropout = graphview.getLayerByLayerpos(currentPos) as Dropout
		//var Dropout dropout = graph.getByID(currentPos) as Dropout
		currentPos++;
		return fsp.writeDropout(dropout.dropoutRate, X_or_shortcut)
	}
	
	def unitDense(String X_or_shortcut){
		var Dense dense = graphview.getLayerByLayerpos(currentPos) as Dense
		//var Dense dense = graph.getByID(currentPos) as Dense
		currentPos++
		return fsp.writeDense(dense.units,dense.fctActivation, X_or_shortcut)
	}
	
	def unitFlatten(String X_or_shortcut){
		currentPos++
		return fsp.writeFlatten(X_or_shortcut)
	}
	
	def unitGlobalPooling(String elem, String X_or_shortcut){
		currentPos++
		if(elem == "global_avg_pooling"){
			return fsp.writeGloAvgPooling(X_or_shortcut)	
		}else {
			return fsp.writeGloMaxPooling(X_or_shortcut)
		}
	}
		
	
}