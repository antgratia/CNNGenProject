/*
 * generated by Xtext 2.26.0
 */
package xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xtext.cNNDescLang.Architecture;
import xtext.cNNDescLang.CNNDescLang;
import xtext.cNNDescLang.CNNDescLangPackage;
import xtext.cNNDescLang.Classification;
import xtext.cNNDescLang.ConvDrop;
import xtext.cNNDescLang.ConvOrMerge;
import xtext.cNNDescLang.Convolution;
import xtext.cNNDescLang.FeatureExtraction;
import xtext.cNNDescLang.FlattenOrGlobal;
import xtext.cNNDescLang.Interstice;
import xtext.cNNDescLang.Left;
import xtext.cNNDescLang.Merge;
import xtext.cNNDescLang.MergeBody;
import xtext.cNNDescLang.MergeConv;
import xtext.cNNDescLang.Right;
import xtext.services.CNNDescLangGrammarAccess;

@SuppressWarnings("all")
public class CNNDescLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CNNDescLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CNNDescLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CNNDescLangPackage.ARCHITECTURE:
				sequence_Architecture(context, (Architecture) semanticObject); 
				return; 
			case CNNDescLangPackage.CNN_DESC_LANG:
				sequence_CNNDescLang(context, (CNNDescLang) semanticObject); 
				return; 
			case CNNDescLangPackage.CLASSIFICATION:
				sequence_Classification(context, (Classification) semanticObject); 
				return; 
			case CNNDescLangPackage.CONV_DROP:
				sequence_ConvDrop(context, (ConvDrop) semanticObject); 
				return; 
			case CNNDescLangPackage.CONV_OR_MERGE:
				sequence_ConvOrMerge(context, (ConvOrMerge) semanticObject); 
				return; 
			case CNNDescLangPackage.CONVOLUTION:
				sequence_Convolution(context, (Convolution) semanticObject); 
				return; 
			case CNNDescLangPackage.FEATURE_EXTRACTION:
				sequence_FeatureExtraction(context, (FeatureExtraction) semanticObject); 
				return; 
			case CNNDescLangPackage.FLATTEN_OR_GLOBAL:
				sequence_FlattenOrGlobal(context, (FlattenOrGlobal) semanticObject); 
				return; 
			case CNNDescLangPackage.INTERSTICE:
				sequence_Interstice(context, (Interstice) semanticObject); 
				return; 
			case CNNDescLangPackage.LEFT:
				sequence_Left(context, (Left) semanticObject); 
				return; 
			case CNNDescLangPackage.MERGE:
				sequence_Merge(context, (Merge) semanticObject); 
				return; 
			case CNNDescLangPackage.MERGE_BODY:
				sequence_MergeBody(context, (MergeBody) semanticObject); 
				return; 
			case CNNDescLangPackage.MERGE_CONV:
				sequence_MergeConv(context, (MergeConv) semanticObject); 
				return; 
			case CNNDescLangPackage.RIGHT:
				sequence_Right(context, (Right) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Architecture returns Architecture
	 *
	 * Constraint:
	 *     (input='input' fe+=FeatureExtraction+ (inter=Interstice class+=Classification+)? output='output')
	 * </pre>
	 */
	protected void sequence_Architecture(ISerializationContext context, Architecture semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CNNDescLang returns CNNDescLang
	 *
	 * Constraint:
	 *     cnndesclang=Architecture
	 * </pre>
	 */
	protected void sequence_CNNDescLang(ISerializationContext context, CNNDescLang semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNNDescLangPackage.Literals.CNN_DESC_LANG__CNNDESCLANG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNNDescLangPackage.Literals.CNN_DESC_LANG__CNNDESCLANG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCNNDescLangAccess().getCnndesclangArchitectureParserRuleCall_0(), semanticObject.getCnndesclang());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Classification returns Classification
	 *
	 * Constraint:
	 *     (drop=Dropout? d='dense')
	 * </pre>
	 */
	protected void sequence_Classification(ISerializationContext context, Classification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConvDrop returns ConvDrop
	 *
	 * Constraint:
	 *     (conv=Convolution drop=Dropout?)
	 * </pre>
	 */
	protected void sequence_ConvDrop(ISerializationContext context, ConvDrop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConvOrMerge returns ConvOrMerge
	 *
	 * Constraint:
	 *     (convdrop+=ConvDrop+ | (convdrop+=ConvDrop* mergeConv+=MergeConv+))
	 * </pre>
	 */
	protected void sequence_ConvOrMerge(ISerializationContext context, ConvOrMerge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Convolution returns Convolution
	 *
	 * Constraint:
	 *     (bnconv='bnconv' | convbn='convbn' | conv='conv' | upconv='upconv')
	 * </pre>
	 */
	protected void sequence_Convolution(ISerializationContext context, Convolution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FeatureExtraction returns FeatureExtraction
	 *
	 * Constraint:
	 *     ((conv=Convolution | merge=Merge) drop=Dropout? pool=Pooling?)
	 * </pre>
	 */
	protected void sequence_FeatureExtraction(ISerializationContext context, FeatureExtraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FlattenOrGlobal returns FlattenOrGlobal
	 *
	 * Constraint:
	 *     (flat='flatten' | gp=GlobalPooling)
	 * </pre>
	 */
	protected void sequence_FlattenOrGlobal(ISerializationContext context, FlattenOrGlobal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interstice returns Interstice
	 *
	 * Constraint:
	 *     fg=FlattenOrGlobal
	 * </pre>
	 */
	protected void sequence_Interstice(ISerializationContext context, Interstice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNNDescLangPackage.Literals.INTERSTICE__FG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNNDescLangPackage.Literals.INTERSTICE__FG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntersticeAccess().getFgFlattenOrGlobalParserRuleCall_0(), semanticObject.getFg());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Left returns Left
	 *
	 * Constraint:
	 *     (p=Pooling? com=ConvOrMerge pool=Pooling?)
	 * </pre>
	 */
	protected void sequence_Left(ISerializationContext context, Left semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MergeBody returns MergeBody
	 *
	 * Constraint:
	 *     (left=Left virg=',' right=Right)
	 * </pre>
	 */
	protected void sequence_MergeBody(ISerializationContext context, MergeBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CNNDescLangPackage.Literals.MERGE_BODY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNNDescLangPackage.Literals.MERGE_BODY__LEFT));
			if (transientValues.isValueTransient(semanticObject, CNNDescLangPackage.Literals.MERGE_BODY__VIRG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNNDescLangPackage.Literals.MERGE_BODY__VIRG));
			if (transientValues.isValueTransient(semanticObject, CNNDescLangPackage.Literals.MERGE_BODY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CNNDescLangPackage.Literals.MERGE_BODY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMergeBodyAccess().getLeftLeftParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMergeBodyAccess().getVirgCommaKeyword_2_0(), semanticObject.getVirg());
		feeder.accept(grammarAccess.getMergeBodyAccess().getRightRightParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MergeConv returns MergeConv
	 *
	 * Constraint:
	 *     (merge=Merge convdrop+=ConvDrop*)
	 * </pre>
	 */
	protected void sequence_MergeConv(ISerializationContext context, MergeConv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Merge returns Merge
	 *
	 * Constraint:
	 *     (db='[' mergeBody+=MergeBody+ fm=']')
	 * </pre>
	 */
	protected void sequence_Merge(ISerializationContext context, Merge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Right returns Right
	 *
	 * Constraint:
	 *     (conv+=Convolution+ | empty='Empty')
	 * </pre>
	 */
	protected void sequence_Right(ISerializationContext context, Right semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
